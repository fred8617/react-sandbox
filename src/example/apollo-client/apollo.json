{
    "version": "3.0.0",
    "types": {
      "@apollo/client/cache/core/cache.d.ts": "import { DocumentNode } from 'graphql';\r\nimport { StoreObject, Reference } from '../../utilities';\r\nimport { DataProxy } from './types/DataProxy';\r\nimport { Cache } from './types/Cache';\r\nexport declare type Transaction<T> = (c: ApolloCache<T>) => void;\r\nexport declare abstract class ApolloCache<TSerialized> implements DataProxy {\r\n    abstract read<T, TVariables = any>(query: Cache.ReadOptions<TVariables, T>): T | null;\r\n    abstract write<TResult = any, TVariables = any>(write: Cache.WriteOptions<TResult, TVariables>): Reference | undefined;\r\n    abstract diff<T>(query: Cache.DiffOptions): Cache.DiffResult<T>;\r\n    abstract watch(watch: Cache.WatchOptions): () => void;\r\n    abstract reset(): Promise<void>;\r\n    abstract evict(options: Cache.EvictOptions): boolean;\r\n    abstract restore(serializedState: TSerialized): ApolloCache<TSerialized>;\r\n    abstract extract(optimistic?: boolean): TSerialized;\r\n    abstract removeOptimistic(id: string): void;\r\n    abstract performTransaction(transaction: Transaction<TSerialized>, optimisticId?: string | null): void;\r\n    recordOptimisticTransaction(transaction: Transaction<TSerialized>, optimisticId: string): void;\r\n    transformDocument(document: DocumentNode): DocumentNode;\r\n    identify(object: StoreObject | Reference): string | undefined;\r\n    gc(): string[];\r\n    modify(options: Cache.ModifyOptions): boolean;\r\n    transformForLink(document: DocumentNode): DocumentNode;\r\n    readQuery<QueryType, TVariables = any>(options: DataProxy.Query<TVariables, QueryType>, optimistic?: boolean): QueryType | null;\r\n    private getFragmentDoc;\r\n    readFragment<FragmentType, TVariables = any>(options: DataProxy.Fragment<TVariables, FragmentType>, optimistic?: boolean): FragmentType | null;\r\n    writeQuery<TData = any, TVariables = any>(options: Cache.WriteQueryOptions<TData, TVariables>): Reference | undefined;\r\n    writeFragment<TData = any, TVariables = any>(options: Cache.WriteFragmentOptions<TData, TVariables>): Reference | undefined;\r\n}\r\n",
      "@apollo/client/cache/core/types/Cache.d.ts": "import { DataProxy } from './DataProxy';\r\nimport { Modifier, Modifiers } from './common';\r\nexport declare namespace Cache {\r\n    type WatchCallback = (diff: Cache.DiffResult<any>) => void;\r\n    interface ReadOptions<TVariables = any, TData = any> extends DataProxy.Query<TVariables, TData> {\r\n        rootId?: string;\r\n        previousResult?: any;\r\n        optimistic: boolean;\r\n    }\r\n    interface WriteOptions<TResult = any, TVariables = any> extends DataProxy.Query<TVariables, TResult> {\r\n        dataId?: string;\r\n        result: TResult;\r\n        broadcast?: boolean;\r\n    }\r\n    interface DiffOptions extends ReadOptions {\r\n        returnPartialData?: boolean;\r\n    }\r\n    interface WatchOptions extends ReadOptions {\r\n        immediate?: boolean;\r\n        callback: WatchCallback;\r\n    }\r\n    interface EvictOptions {\r\n        id?: string;\r\n        fieldName?: string;\r\n        args?: Record<string, any>;\r\n        broadcast?: boolean;\r\n    }\r\n    interface ModifyOptions {\r\n        id?: string;\r\n        fields: Modifiers | Modifier<any>;\r\n        optimistic?: boolean;\r\n        broadcast?: boolean;\r\n    }\r\n    export import DiffResult = DataProxy.DiffResult;\r\n    export import WriteQueryOptions = DataProxy.WriteQueryOptions;\r\n    export import WriteFragmentOptions = DataProxy.WriteFragmentOptions;\r\n    export import Fragment = DataProxy.Fragment;\r\n}\r\n",
      "@apollo/client/cache/core/types/common.d.ts": "import { FieldNode } from 'graphql';\r\nimport { Reference, StoreObject, StoreValue, isReference } from '../../../utilities';\r\nimport { StorageType } from '../../inmemory/policies';\r\nexport declare type SafeReadonly<T> = T extends object ? Readonly<T> : T;\r\nexport declare class MissingFieldError {\r\n    readonly message: string;\r\n    readonly path: (string | number)[];\r\n    readonly query: import('graphql').DocumentNode;\r\n    readonly clientOnly: boolean;\r\n    readonly variables?: Record<string, any> | undefined;\r\n    constructor(message: string, path: (string | number)[], query: import('graphql').DocumentNode, clientOnly: boolean, variables?: Record<string, any> | undefined);\r\n}\r\nexport interface FieldSpecifier {\r\n    typename?: string;\r\n    fieldName: string;\r\n    field?: FieldNode;\r\n    args?: Record<string, any>;\r\n    variables?: Record<string, any>;\r\n}\r\nexport interface ReadFieldOptions extends FieldSpecifier {\r\n    from?: StoreObject | Reference;\r\n}\r\nexport interface ReadFieldFunction {\r\n    <V = StoreValue>(options: ReadFieldOptions): SafeReadonly<V> | undefined;\r\n    <V = StoreValue>(fieldName: string, from?: StoreObject | Reference): SafeReadonly<V> | undefined;\r\n}\r\nexport declare type ToReferenceFunction = (objOrIdOrRef: StoreObject | string | Reference, mergeIntoStore?: boolean) => Reference | undefined;\r\nexport declare type CanReadFunction = (value: StoreValue) => boolean;\r\nexport declare type Modifier<T> = (value: T, details: {\r\n    DELETE: any;\r\n    INVALIDATE: any;\r\n    fieldName: string;\r\n    storeFieldName: string;\r\n    readField: ReadFieldFunction;\r\n    canRead: CanReadFunction;\r\n    isReference: typeof isReference;\r\n    toReference: ToReferenceFunction;\r\n    storage: StorageType;\r\n}) => T;\r\nexport declare type Modifiers = {\r\n    [fieldName: string]: Modifier<any>;\r\n};\r\n",
      "@apollo/client/cache/core/types/DataProxy.d.ts": "import { DocumentNode } from 'graphql';\r\nimport { TypedDocumentNode } from '@graphql-typed-document-node/core';\r\nimport { MissingFieldError } from './common';\r\nexport declare namespace DataProxy {\r\n    interface Query<TVariables, TData> {\r\n        query: DocumentNode | TypedDocumentNode<TData, TVariables>;\r\n        variables?: TVariables;\r\n        id?: string;\r\n    }\r\n    interface Fragment<TVariables, TData> {\r\n        id?: string;\r\n        fragment: DocumentNode | TypedDocumentNode<TData, TVariables>;\r\n        fragmentName?: string;\r\n        variables?: TVariables;\r\n    }\r\n    interface WriteQueryOptions<TData, TVariables> extends Query<TVariables, TData> {\r\n        data: TData;\r\n        broadcast?: boolean;\r\n    }\r\n    interface WriteFragmentOptions<TData, TVariables> extends Fragment<TVariables, TData> {\r\n        data: TData;\r\n        broadcast?: boolean;\r\n    }\r\n    type DiffResult<T> = {\r\n        result?: T;\r\n        complete?: boolean;\r\n        missing?: MissingFieldError[];\r\n        fromOptimisticTransaction?: boolean;\r\n    };\r\n}\r\nexport interface DataProxy {\r\n    readQuery<QueryType, TVariables = any>(options: DataProxy.Query<TVariables, QueryType>, optimistic?: boolean): QueryType | null;\r\n    readFragment<FragmentType, TVariables = any>(options: DataProxy.Fragment<TVariables, FragmentType>, optimistic?: boolean): FragmentType | null;\r\n    writeQuery<TData = any, TVariables = any>(options: DataProxy.WriteQueryOptions<TData, TVariables>): void;\r\n    writeFragment<TData = any, TVariables = any>(options: DataProxy.WriteFragmentOptions<TData, TVariables>): void;\r\n}\r\n",
      "@apollo/client/cache/index.d.ts": "export { Transaction, ApolloCache } from './core/cache';\r\nexport { Cache } from './core/types/Cache';\r\nexport { DataProxy } from './core/types/DataProxy';\r\nexport { MissingFieldError } from './core/types/common';\r\nexport { Reference, isReference, makeReference, } from '../utilities';\r\nexport { InMemoryCache, InMemoryCacheConfig, } from './inmemory/inMemoryCache';\r\nexport { ReactiveVar, makeVar, cacheSlot, } from './inmemory/reactiveVars';\r\nexport { defaultDataIdFromObject, TypePolicies, TypePolicy, FieldPolicy, FieldReadFunction, FieldMergeFunction, FieldFunctionOptions, PossibleTypesMap, } from './inmemory/policies';\r\nexport * from './inmemory/types';\r\n",
      "@apollo/client/cache/inmemory/entityStore.d.ts": "import { KeyTrie } from 'optimism';\r\nimport { StoreValue, StoreObject, Reference } from '../../utilities';\r\nimport { NormalizedCache, NormalizedCacheObject } from './types';\r\nimport { Policies, StorageType } from './policies';\r\nimport { Cache } from '../core/types/Cache';\r\nimport { SafeReadonly, Modifier, Modifiers, ToReferenceFunction, CanReadFunction } from '../core/types/common';\r\nexport declare abstract class EntityStore implements NormalizedCache {\r\n    readonly policies: Policies;\r\n    readonly group: CacheGroup;\r\n    protected data: NormalizedCacheObject;\r\n    constructor(policies: Policies, group: CacheGroup);\r\n    abstract addLayer(layerId: string, replay: (layer: EntityStore) => any): Layer;\r\n    abstract removeLayer(layerId: string): EntityStore;\r\n    toObject(): NormalizedCacheObject;\r\n    has(dataId: string): boolean;\r\n    get(dataId: string, fieldName: string): StoreValue;\r\n    protected lookup(dataId: string, dependOnExistence?: boolean): StoreObject | undefined;\r\n    merge(dataId: string, incoming: StoreObject): void;\r\n    modify(dataId: string, fields: Modifier<any> | Modifiers): boolean;\r\n    delete(dataId: string, fieldName?: string, args?: Record<string, any>): boolean;\r\n    evict(options: Cache.EvictOptions): boolean;\r\n    clear(): void;\r\n    replace(newData: NormalizedCacheObject | null): void;\r\n    abstract getStorage(idOrObj: string | StoreObject, storeFieldName: string): StorageType;\r\n    private rootIds;\r\n    retain(rootId: string): number;\r\n    release(rootId: string): number;\r\n    getRootIdSet(ids?: Set<string>): Set<string>;\r\n    gc(): string[];\r\n    private refs;\r\n    findChildRefIds(dataId: string): Record<string, true>;\r\n    makeCacheKey(...args: any[]): object;\r\n    getFieldValue: <T = StoreValue>(objectOrReference: StoreObject | Reference, storeFieldName: string) => SafeReadonly<T>;\r\n    canRead: CanReadFunction;\r\n    toReference: ToReferenceFunction;\r\n}\r\nexport declare type FieldValueGetter = EntityStore[\"getFieldValue\"];\r\ndeclare class CacheGroup {\r\n    readonly caching: boolean;\r\n    private d;\r\n    constructor(caching: boolean);\r\n    depend(dataId: string, storeFieldName: string): void;\r\n    dirty(dataId: string, storeFieldName: string): void;\r\n    readonly keyMaker: KeyTrie<object>;\r\n}\r\nexport declare namespace EntityStore {\r\n    class Root extends EntityStore {\r\n        private sharedLayerGroup;\r\n        constructor({ policies, resultCaching, seed, }: {\r\n            policies: Policies;\r\n            resultCaching?: boolean;\r\n            seed?: NormalizedCacheObject;\r\n        });\r\n        addLayer(layerId: string, replay: (layer: EntityStore) => any): Layer;\r\n        removeLayer(): Root;\r\n        readonly storageTrie: KeyTrie<Record<string, any>>;\r\n        getStorage(idOrObj: string | StoreObject, storeFieldName: string): StorageType;\r\n    }\r\n}\r\ndeclare class Layer extends EntityStore {\r\n    readonly id: string;\r\n    readonly parent: EntityStore;\r\n    readonly replay: (layer: EntityStore) => any;\r\n    readonly group: CacheGroup;\r\n    constructor(id: string, parent: EntityStore, replay: (layer: EntityStore) => any, group: CacheGroup);\r\n    addLayer(layerId: string, replay: (layer: EntityStore) => any): Layer;\r\n    removeLayer(layerId: string): EntityStore;\r\n    toObject(): NormalizedCacheObject;\r\n    findChildRefIds(dataId: string): Record<string, true>;\r\n    getStorage(idOrObj: string | StoreObject, storeFieldName: string): StorageType;\r\n}\r\nexport declare function supportsResultCaching(store: any): store is EntityStore;\r\nexport {};\r\n",
      "@apollo/client/cache/inmemory/fixPolyfills.d.ts": "",
      "@apollo/client/cache/inmemory/fixPolyfills.native.d.ts": "export {};\r\n",
      "@apollo/client/cache/inmemory/helpers.d.ts": "import { FieldNode, SelectionSetNode } from 'graphql';\r\nimport { NormalizedCache } from './types';\r\nimport { Reference, StoreValue, StoreObject, DeepMerger } from '../../utilities';\r\nexport declare const hasOwn: (v: string | number | symbol) => boolean;\r\nexport declare function getTypenameFromStoreObject(store: NormalizedCache, objectOrReference: StoreObject | Reference): string | undefined;\r\nexport declare const TypeOrFieldNameRegExp: RegExp;\r\nexport declare function fieldNameFromStoreName(storeFieldName: string): string;\r\nexport declare function selectionSetMatchesResult(selectionSet: SelectionSetNode, result: Record<string, any>, variables?: Record<string, any>): boolean;\r\nexport interface FieldValueToBeMerged {\r\n    __field: FieldNode;\r\n    __typename: string;\r\n    __value: StoreValue;\r\n}\r\nexport declare function storeValueIsStoreObject(value: StoreValue): value is StoreObject;\r\nexport declare function isFieldValueToBeMerged(value: any): value is FieldValueToBeMerged;\r\nexport declare function makeProcessedFieldsMerger(): DeepMerger<[]>;\r\n",
      "@apollo/client/cache/inmemory/inMemoryCache.d.ts": "import './fixPolyfills';\r\nimport { DocumentNode } from 'graphql';\r\nimport { ApolloCache } from '../core/cache';\r\nimport { Cache } from '../core/types/Cache';\r\nimport { StoreObject, Reference } from '../../utilities';\r\nimport { ApolloReducerConfig, NormalizedCacheObject } from './types';\r\nimport { makeVar } from './reactiveVars';\r\nimport { PossibleTypesMap, Policies, TypePolicies } from './policies';\r\nexport interface InMemoryCacheConfig extends ApolloReducerConfig {\r\n    resultCaching?: boolean;\r\n    possibleTypes?: PossibleTypesMap;\r\n    typePolicies?: TypePolicies;\r\n}\r\nexport declare class InMemoryCache extends ApolloCache<NormalizedCacheObject> {\r\n    private data;\r\n    private optimisticData;\r\n    protected config: InMemoryCacheConfig;\r\n    private watches;\r\n    private addTypename;\r\n    private typenameDocumentCache;\r\n    private storeReader;\r\n    private storeWriter;\r\n    readonly policies: Policies;\r\n    readonly makeVar: typeof makeVar;\r\n    constructor(config?: InMemoryCacheConfig);\r\n    restore(data: NormalizedCacheObject): this;\r\n    extract(optimistic?: boolean): NormalizedCacheObject;\r\n    read<T>(options: Cache.ReadOptions): T | null;\r\n    write(options: Cache.WriteOptions): Reference | undefined;\r\n    modify(options: Cache.ModifyOptions): boolean;\r\n    diff<T>(options: Cache.DiffOptions): Cache.DiffResult<T>;\r\n    watch(watch: Cache.WatchOptions): () => void;\r\n    gc(): string[];\r\n    retain(rootId: string, optimistic?: boolean): number;\r\n    release(rootId: string, optimistic?: boolean): number;\r\n    identify(object: StoreObject | Reference): string | undefined;\r\n    evict(options: Cache.EvictOptions): boolean;\r\n    reset(): Promise<void>;\r\n    removeOptimistic(idToRemove: string): void;\r\n    private txCount;\r\n    performTransaction(transaction: (cache: InMemoryCache) => any, optimisticId?: string | null): void;\r\n    transformDocument(document: DocumentNode): DocumentNode;\r\n    protected broadcastWatches(fromOptimisticTransaction?: boolean): void;\r\n    private maybeBroadcastWatch;\r\n    private watchDep;\r\n    private broadcastWatch;\r\n}\r\n",
      "@apollo/client/cache/inmemory/policies.d.ts": "import { InlineFragmentNode, FragmentDefinitionNode, SelectionSetNode, FieldNode } from 'graphql';\r\nimport { FragmentMap, StoreValue, StoreObject, Reference, isReference } from '../../utilities';\r\nimport { IdGetter, ReadMergeModifyContext } from \"./types\";\r\nimport { FieldValueToBeMerged } from './helpers';\r\nimport { InMemoryCache } from './inMemoryCache';\r\nimport { SafeReadonly, FieldSpecifier, ToReferenceFunction, ReadFieldFunction, ReadFieldOptions, CanReadFunction } from '../core/types/common';\r\nexport declare type TypePolicies = {\r\n    [__typename: string]: TypePolicy;\r\n};\r\ndeclare type KeySpecifier = (string | any[])[];\r\ndeclare type KeyFieldsContext = {\r\n    typename?: string;\r\n    selectionSet?: SelectionSetNode;\r\n    fragmentMap?: FragmentMap;\r\n    keyObject?: Record<string, any>;\r\n};\r\nexport declare type KeyFieldsFunction = (object: Readonly<StoreObject>, context: KeyFieldsContext) => KeySpecifier | ReturnType<IdGetter>;\r\nexport declare type TypePolicy = {\r\n    keyFields?: KeySpecifier | KeyFieldsFunction | false;\r\n    queryType?: true;\r\n    mutationType?: true;\r\n    subscriptionType?: true;\r\n    fields?: {\r\n        [fieldName: string]: FieldPolicy<any> | FieldReadFunction<any>;\r\n    };\r\n};\r\nexport declare type KeyArgsFunction = (args: Record<string, any> | null, context: {\r\n    typename: string;\r\n    fieldName: string;\r\n    field: FieldNode | null;\r\n    variables?: Record<string, any>;\r\n}) => KeySpecifier | ReturnType<IdGetter>;\r\nexport declare type FieldPolicy<TExisting = any, TIncoming = TExisting, TReadResult = TExisting> = {\r\n    keyArgs?: KeySpecifier | KeyArgsFunction | false;\r\n    read?: FieldReadFunction<TExisting, TReadResult>;\r\n    merge?: FieldMergeFunction<TExisting, TIncoming> | boolean;\r\n};\r\nexport declare type StorageType = Record<string, any>;\r\nexport interface FieldFunctionOptions<TArgs = Record<string, any>, TVars = Record<string, any>> {\r\n    args: TArgs | null;\r\n    fieldName: string;\r\n    storeFieldName: string;\r\n    field: FieldNode | null;\r\n    variables?: TVars;\r\n    isReference: typeof isReference;\r\n    toReference: ToReferenceFunction;\r\n    storage: StorageType;\r\n    cache: InMemoryCache;\r\n    readField: ReadFieldFunction;\r\n    canRead: CanReadFunction;\r\n    mergeObjects<T extends StoreObject | Reference>(existing: T, incoming: T): T | undefined;\r\n}\r\nexport declare type FieldReadFunction<TExisting = any, TReadResult = TExisting> = (existing: SafeReadonly<TExisting> | undefined, options: FieldFunctionOptions) => TReadResult | undefined;\r\nexport declare type FieldMergeFunction<TExisting = any, TIncoming = TExisting> = (existing: SafeReadonly<TExisting> | undefined, incoming: SafeReadonly<TIncoming>, options: FieldFunctionOptions) => SafeReadonly<TExisting>;\r\nexport declare const defaultDataIdFromObject: ({ __typename, id, _id }: Readonly<StoreObject>, context?: KeyFieldsContext | undefined) => string | undefined;\r\nexport declare type PossibleTypesMap = {\r\n    [supertype: string]: string[];\r\n};\r\nexport declare class Policies {\r\n    private config;\r\n    private typePolicies;\r\n    private supertypeMap;\r\n    private fuzzySubtypes;\r\n    readonly cache: InMemoryCache;\r\n    readonly rootIdsByTypename: Record<string, string>;\r\n    readonly rootTypenamesById: Record<string, string>;\r\n    readonly usingPossibleTypes = false;\r\n    constructor(config: {\r\n        cache: InMemoryCache;\r\n        dataIdFromObject?: KeyFieldsFunction;\r\n        possibleTypes?: PossibleTypesMap;\r\n        typePolicies?: TypePolicies;\r\n    });\r\n    identify(object: StoreObject, selectionSet?: SelectionSetNode, fragmentMap?: FragmentMap): [string?, StoreObject?];\r\n    addTypePolicies(typePolicies: TypePolicies): void;\r\n    private setRootTypename;\r\n    addPossibleTypes(possibleTypes: PossibleTypesMap): void;\r\n    private getTypePolicy;\r\n    private getFieldPolicy;\r\n    private getSupertypeSet;\r\n    fragmentMatches(fragment: InlineFragmentNode | FragmentDefinitionNode, typename: string | undefined, result?: Record<string, any>, variables?: Record<string, any>): boolean;\r\n    getStoreFieldName(fieldSpec: FieldSpecifier): string;\r\n    readField<V = StoreValue>(options: ReadFieldOptions, context: ReadMergeModifyContext): SafeReadonly<V> | undefined;\r\n    hasMergeFunction(typename: string | undefined, fieldName: string): boolean;\r\n    applyMerges<T extends StoreValue>(existing: T | Reference, incoming: T | FieldValueToBeMerged, context: ReadMergeModifyContext, storageKeys?: [string | StoreObject, string]): T;\r\n}\r\nexport {};\r\n",
      "@apollo/client/cache/inmemory/reactiveVars.d.ts": "import { ApolloCache } from '../../core';\r\nexport interface ReactiveVar<T> {\r\n    (newValue?: T): T;\r\n    onNextChange(listener: ReactiveListener<T>): () => void;\r\n}\r\nexport declare type ReactiveListener<T> = (value: T) => any;\r\nexport declare const cacheSlot: {\r\n    readonly id: string;\r\n    hasValue(): boolean;\r\n    getValue(): ApolloCache<any> | undefined;\r\n    withValue<TResult, TArgs extends any[], TThis = any>(value: ApolloCache<any>, callback: (this: TThis, ...args: TArgs) => TResult, args?: TArgs | undefined, thisArg?: TThis | undefined): TResult;\r\n};\r\nexport declare function makeVar<T>(value: T): ReactiveVar<T>;\r\n",
      "@apollo/client/cache/inmemory/readFromStore.d.ts": "import { SelectionSetNode } from 'graphql';\r\nimport { Reference, StoreObject } from '../../utilities';\r\nimport { Cache } from '../core/types/Cache';\r\nimport { DiffQueryAgainstStoreOptions, ReadMergeModifyContext } from './types';\r\nimport { InMemoryCache } from './inMemoryCache';\r\nimport { MissingFieldError } from '../core/types/common';\r\nexport declare type VariableMap = {\r\n    [name: string]: any;\r\n};\r\nexport declare type ExecResult<R = any> = {\r\n    result: R;\r\n    missing?: MissingFieldError[];\r\n};\r\nexport interface StoreReaderConfig {\r\n    cache: InMemoryCache;\r\n    addTypename?: boolean;\r\n}\r\nexport declare class StoreReader {\r\n    private config;\r\n    constructor(config: StoreReaderConfig);\r\n    diffQueryAgainstStore<T>({ store, query, rootId, variables, returnPartialData, }: DiffQueryAgainstStoreOptions): Cache.DiffResult<T>;\r\n    isFresh(result: Record<string, any>, parent: StoreObject | Reference, selectionSet: SelectionSetNode, context: ReadMergeModifyContext): boolean;\r\n    private executeSelectionSet;\r\n    private execSelectionSetImpl;\r\n    private knownResults;\r\n    private executeSubSelectedArray;\r\n    private execSubSelectedArrayImpl;\r\n}\r\n",
      "@apollo/client/cache/inmemory/types.d.ts": "import { DocumentNode } from 'graphql';\r\nimport { Transaction } from '../core/cache';\r\nimport { StoreObject, StoreValue, Reference } from '../../utilities';\r\nimport { FieldValueGetter } from './entityStore';\r\nimport { KeyFieldsFunction, StorageType } from './policies';\r\nimport { Modifier, Modifiers, ToReferenceFunction, CanReadFunction } from '../core/types/common';\r\nexport { StoreObject, StoreValue, Reference };\r\nexport interface IdGetterObj extends Object {\r\n    __typename?: string;\r\n    id?: string;\r\n    _id?: string;\r\n}\r\nexport declare type IdGetter = (value: IdGetterObj) => string | undefined;\r\nexport interface NormalizedCache {\r\n    has(dataId: string): boolean;\r\n    get(dataId: string, fieldName: string): StoreValue;\r\n    merge(dataId: string, incoming: StoreObject): void;\r\n    modify(dataId: string, fields: Modifiers | Modifier<any>): boolean;\r\n    delete(dataId: string, fieldName?: string): boolean;\r\n    clear(): void;\r\n    toObject(): NormalizedCacheObject;\r\n    replace(newData: NormalizedCacheObject): void;\r\n    retain(rootId: string): number;\r\n    release(rootId: string): number;\r\n    getFieldValue: FieldValueGetter;\r\n    toReference: ToReferenceFunction;\r\n    canRead: CanReadFunction;\r\n    getStorage(idOrObj: string | StoreObject, storeFieldName: string): StorageType;\r\n}\r\nexport interface NormalizedCacheObject {\r\n    [dataId: string]: StoreObject | undefined;\r\n}\r\nexport declare type OptimisticStoreItem = {\r\n    id: string;\r\n    data: NormalizedCacheObject;\r\n    transaction: Transaction<NormalizedCacheObject>;\r\n};\r\nexport declare type ReadQueryOptions = {\r\n    store: NormalizedCache;\r\n    query: DocumentNode;\r\n    variables?: Object;\r\n    previousResult?: any;\r\n    rootId?: string;\r\n    config?: ApolloReducerConfig;\r\n};\r\nexport declare type DiffQueryAgainstStoreOptions = ReadQueryOptions & {\r\n    returnPartialData?: boolean;\r\n};\r\nexport declare type ApolloReducerConfig = {\r\n    dataIdFromObject?: KeyFieldsFunction;\r\n    addTypename?: boolean;\r\n};\r\nexport interface ReadMergeModifyContext {\r\n    store: NormalizedCache;\r\n    variables?: Record<string, any>;\r\n    varString?: string;\r\n}\r\n",
      "@apollo/client/cache/inmemory/writeToStore.d.ts": "import { SelectionSetNode, DocumentNode } from 'graphql';\r\nimport { FragmentMap, Reference } from '../../utilities';\r\nimport { NormalizedCache, ReadMergeModifyContext } from './types';\r\nimport { StoreReader } from './readFromStore';\r\nimport { InMemoryCache } from './inMemoryCache';\r\nexport interface WriteContext extends ReadMergeModifyContext {\r\n    readonly written: {\r\n        [dataId: string]: SelectionSetNode[];\r\n    };\r\n    readonly fragmentMap?: FragmentMap;\r\n    merge<T>(existing: T, incoming: T): T;\r\n}\r\nexport interface WriteToStoreOptions {\r\n    query: DocumentNode;\r\n    result: Object;\r\n    dataId?: string;\r\n    store: NormalizedCache;\r\n    variables?: Object;\r\n}\r\nexport declare class StoreWriter {\r\n    readonly cache: InMemoryCache;\r\n    private reader?;\r\n    constructor(cache: InMemoryCache, reader?: StoreReader | undefined);\r\n    writeToStore({ query, result, dataId, store, variables, }: WriteToStoreOptions): Reference | undefined;\r\n    private processSelectionSet;\r\n    private processFieldValue;\r\n}\r\n",
      "@apollo/client/config/jest/setup.d.ts": "export {};\r\n",
      "@apollo/client/core/ApolloClient.d.ts": "/// <reference types=\"zen-observable\" />\r\nimport { ExecutionResult, DocumentNode } from 'graphql';\r\nimport { ApolloLink, FetchResult, GraphQLRequest } from '../link/core';\r\nimport { ApolloCache, DataProxy } from '../cache';\r\nimport { Observable } from '../utilities';\r\nimport { UriFunction } from '../link/http';\r\nimport { ObservableQuery } from './ObservableQuery';\r\nimport { ApolloQueryResult, OperationVariables, Resolvers } from './types';\r\nimport { QueryOptions, WatchQueryOptions, MutationOptions, SubscriptionOptions } from './watchQueryOptions';\r\nimport { FragmentMatcher } from './LocalState';\r\nexport interface DefaultOptions {\r\n    watchQuery?: Partial<WatchQueryOptions>;\r\n    query?: Partial<QueryOptions>;\r\n    mutate?: Partial<MutationOptions>;\r\n}\r\nexport declare type ApolloClientOptions<TCacheShape> = {\r\n    uri?: string | UriFunction;\r\n    credentials?: string;\r\n    headers?: Record<string, string>;\r\n    link?: ApolloLink;\r\n    cache: ApolloCache<TCacheShape>;\r\n    ssrForceFetchDelay?: number;\r\n    ssrMode?: boolean;\r\n    connectToDevTools?: boolean;\r\n    queryDeduplication?: boolean;\r\n    defaultOptions?: DefaultOptions;\r\n    assumeImmutableResults?: boolean;\r\n    resolvers?: Resolvers | Resolvers[];\r\n    typeDefs?: string | string[] | DocumentNode | DocumentNode[];\r\n    fragmentMatcher?: FragmentMatcher;\r\n    name?: string;\r\n    version?: string;\r\n};\r\nexport declare class ApolloClient<TCacheShape> implements DataProxy {\r\n    link: ApolloLink;\r\n    cache: ApolloCache<TCacheShape>;\r\n    disableNetworkFetches: boolean;\r\n    version: string;\r\n    queryDeduplication: boolean;\r\n    defaultOptions: DefaultOptions;\r\n    readonly typeDefs: ApolloClientOptions<TCacheShape>['typeDefs'];\r\n    private queryManager;\r\n    private devToolsHookCb;\r\n    private resetStoreCallbacks;\r\n    private clearStoreCallbacks;\r\n    private localState;\r\n    constructor(options: ApolloClientOptions<TCacheShape>);\r\n    stop(): void;\r\n    watchQuery<T = any, TVariables = OperationVariables>(options: WatchQueryOptions<TVariables, T>): ObservableQuery<T, TVariables>;\r\n    query<T = any, TVariables = OperationVariables>(options: QueryOptions<TVariables, T>): Promise<ApolloQueryResult<T>>;\r\n    mutate<T = any, TVariables = OperationVariables>(options: MutationOptions<T, TVariables>): Promise<FetchResult<T>>;\r\n    subscribe<T = any, TVariables = OperationVariables>(options: SubscriptionOptions<TVariables, T>): Observable<FetchResult<T>>;\r\n    readQuery<T = any, TVariables = OperationVariables>(options: DataProxy.Query<TVariables, T>, optimistic?: boolean): T | null;\r\n    readFragment<T = any, TVariables = OperationVariables>(options: DataProxy.Fragment<TVariables, T>, optimistic?: boolean): T | null;\r\n    writeQuery<TData = any, TVariables = OperationVariables>(options: DataProxy.WriteQueryOptions<TData, TVariables>): void;\r\n    writeFragment<TData = any, TVariables = OperationVariables>(options: DataProxy.WriteFragmentOptions<TData, TVariables>): void;\r\n    __actionHookForDevTools(cb: () => any): void;\r\n    __requestRaw(payload: GraphQLRequest): Observable<ExecutionResult>;\r\n    resetStore(): Promise<ApolloQueryResult<any>[] | null>;\r\n    clearStore(): Promise<any[]>;\r\n    onResetStore(cb: () => Promise<any>): () => void;\r\n    onClearStore(cb: () => Promise<any>): () => void;\r\n    reFetchObservableQueries(includeStandby?: boolean): Promise<ApolloQueryResult<any>[]>;\r\n    extract(optimistic?: boolean): TCacheShape;\r\n    restore(serializedState: TCacheShape): ApolloCache<TCacheShape>;\r\n    addResolvers(resolvers: Resolvers | Resolvers[]): void;\r\n    setResolvers(resolvers: Resolvers | Resolvers[]): void;\r\n    getResolvers(): Resolvers;\r\n    setLocalStateFragmentMatcher(fragmentMatcher: FragmentMatcher): void;\r\n    setLink(newLink: ApolloLink): void;\r\n}\r\n",
      "@apollo/client/core/index.d.ts": "export { ApolloClient, ApolloClientOptions, DefaultOptions, } from './ApolloClient';\r\nexport { ObservableQuery, FetchMoreOptions, UpdateQueryOptions, } from './ObservableQuery';\r\nexport { QueryBaseOptions, QueryOptions, WatchQueryOptions, MutationOptions, SubscriptionOptions, FetchPolicy, WatchQueryFetchPolicy, ErrorPolicy, FetchMoreQueryOptions, SubscribeToMoreOptions, MutationUpdaterFn, } from './watchQueryOptions';\r\nexport { NetworkStatus } from './networkStatus';\r\nexport * from './types';\r\nexport { Resolver, FragmentMatcher, } from './LocalState';\r\nexport { isApolloError, ApolloError } from '../errors';\r\nexport { Cache, ApolloCache, Transaction, DataProxy, InMemoryCache, InMemoryCacheConfig, MissingFieldError, defaultDataIdFromObject, ReactiveVar, makeVar, TypePolicies, TypePolicy, FieldPolicy, FieldReadFunction, FieldMergeFunction, FieldFunctionOptions, PossibleTypesMap, } from '../cache';\r\nexport * from '../cache/inmemory/types';\r\nexport * from '../link/core';\r\nexport * from '../link/http';\r\nexport { fromError, toPromise, fromPromise, ServerError, throwServerError, } from '../link/utils';\r\nexport { Observable, Observer, ObservableSubscription, Reference, isReference, makeReference, StoreObject, } from '../utilities';\r\nimport gql from 'graphql-tag';\r\nexport declare const resetCaches: typeof gql.resetCaches, disableFragmentWarnings: typeof gql.disableFragmentWarnings, enableExperimentalFragmentVariables: typeof gql.enableExperimentalFragmentVariables, disableExperimentalFragmentVariables: typeof gql.disableExperimentalFragmentVariables;\r\nexport { gql };\r\n",
      "@apollo/client/core/LocalState.d.ts": "import { DocumentNode, FieldNode, ASTNode } from 'graphql';\r\nimport { ApolloCache } from '../cache';\r\nimport { FragmentMap, StoreObject } from '../utilities';\r\nimport { ApolloClient } from './ApolloClient';\r\nimport { Resolvers, OperationVariables } from './types';\r\nimport { FetchResult } from '../link/core';\r\nexport declare type Resolver = (rootValue?: any, args?: any, context?: any, info?: {\r\n    field: FieldNode;\r\n    fragmentMap: FragmentMap;\r\n}) => any;\r\nexport declare type VariableMap = {\r\n    [name: string]: any;\r\n};\r\nexport declare type FragmentMatcher = (rootValue: any, typeCondition: string, context: any) => boolean;\r\nexport declare type ExecContext = {\r\n    fragmentMap: FragmentMap;\r\n    context: any;\r\n    variables: VariableMap;\r\n    fragmentMatcher: FragmentMatcher;\r\n    defaultOperationType: string;\r\n    exportedVariables: Record<string, any>;\r\n    onlyRunForcedResolvers: boolean;\r\n};\r\nexport declare type LocalStateOptions<TCacheShape> = {\r\n    cache: ApolloCache<TCacheShape>;\r\n    client?: ApolloClient<TCacheShape>;\r\n    resolvers?: Resolvers | Resolvers[];\r\n    fragmentMatcher?: FragmentMatcher;\r\n};\r\nexport declare class LocalState<TCacheShape> {\r\n    private cache;\r\n    private client;\r\n    private resolvers?;\r\n    private fragmentMatcher;\r\n    constructor({ cache, client, resolvers, fragmentMatcher, }: LocalStateOptions<TCacheShape>);\r\n    addResolvers(resolvers: Resolvers | Resolvers[]): void;\r\n    setResolvers(resolvers: Resolvers | Resolvers[]): void;\r\n    getResolvers(): Resolvers;\r\n    runResolvers<TData>({ document, remoteResult, context, variables, onlyRunForcedResolvers, }: {\r\n        document: DocumentNode | null;\r\n        remoteResult: FetchResult<TData>;\r\n        context?: Record<string, any>;\r\n        variables?: Record<string, any>;\r\n        onlyRunForcedResolvers?: boolean;\r\n    }): Promise<FetchResult<TData>>;\r\n    setFragmentMatcher(fragmentMatcher: FragmentMatcher): void;\r\n    getFragmentMatcher(): FragmentMatcher;\r\n    clientQuery(document: DocumentNode): DocumentNode | null;\r\n    serverQuery(document: DocumentNode): DocumentNode | null;\r\n    prepareContext(context?: Record<string, any>): {\r\n        cache: ApolloCache<TCacheShape>;\r\n        getCacheKey(obj: StoreObject): string | undefined;\r\n    };\r\n    addExportedVariables(document: DocumentNode, variables?: OperationVariables, context?: {}): Promise<{\r\n        [x: string]: any;\r\n    }>;\r\n    shouldForceResolvers(document: ASTNode): boolean;\r\n    private buildRootValueFromCache;\r\n    private resolveDocument;\r\n    private resolveSelectionSet;\r\n    private resolveField;\r\n    private resolveSubSelectedArray;\r\n}\r\n",
      "@apollo/client/core/MutationStore.d.ts": "import { DocumentNode } from 'graphql';\r\nexport declare class MutationStore {\r\n    private store;\r\n    getStore(): {\r\n        [mutationId: string]: MutationStoreValue;\r\n    };\r\n    get(mutationId: string): MutationStoreValue;\r\n    initMutation(mutationId: string, mutation: DocumentNode, variables: Object | undefined): void;\r\n    markMutationError(mutationId: string, error: Error): void;\r\n    markMutationResult(mutationId: string): void;\r\n    reset(): void;\r\n}\r\nexport interface MutationStoreValue {\r\n    mutation: DocumentNode;\r\n    variables: Object;\r\n    loading: boolean;\r\n    error: Error | null;\r\n}\r\n",
      "@apollo/client/core/networkStatus.d.ts": "export declare enum NetworkStatus {\r\n    loading = 1,\r\n    setVariables = 2,\r\n    fetchMore = 3,\r\n    refetch = 4,\r\n    poll = 6,\r\n    ready = 7,\r\n    error = 8\r\n}\r\nexport declare function isNetworkRequestInFlight(networkStatus?: NetworkStatus): boolean;\r\n",
      "@apollo/client/core/ObservableQuery.d.ts": "/// <reference types=\"zen-observable\" />\r\nimport { NetworkStatus } from './networkStatus';\r\nimport { Observable } from '../utilities';\r\nimport { ApolloError } from '../errors';\r\nimport { QueryManager } from './QueryManager';\r\nimport { ApolloQueryResult, OperationVariables } from './types';\r\nimport { WatchQueryOptions, FetchMoreQueryOptions, SubscribeToMoreOptions } from './watchQueryOptions';\r\nimport { QueryInfo } from './QueryInfo';\r\nexport interface FetchMoreOptions<TData = any, TVariables = OperationVariables> {\r\n    updateQuery?: (previousQueryResult: TData, options: {\r\n        fetchMoreResult?: TData;\r\n        variables?: TVariables;\r\n    }) => TData;\r\n}\r\nexport interface UpdateQueryOptions<TVariables> {\r\n    variables?: TVariables;\r\n}\r\nexport declare class ObservableQuery<TData = any, TVariables = OperationVariables> extends Observable<ApolloQueryResult<TData>> {\r\n    readonly options: WatchQueryOptions<TVariables, TData>;\r\n    readonly queryId: string;\r\n    readonly queryName?: string;\r\n    get variables(): TVariables | undefined;\r\n    private isTornDown;\r\n    private queryManager;\r\n    private observers;\r\n    private subscriptions;\r\n    private lastResult;\r\n    private lastResultSnapshot;\r\n    private lastError;\r\n    private queryInfo;\r\n    constructor({ queryManager, queryInfo, options, }: {\r\n        queryManager: QueryManager<any>;\r\n        queryInfo: QueryInfo;\r\n        options: WatchQueryOptions<TVariables, TData>;\r\n    });\r\n    result(): Promise<ApolloQueryResult<TData>>;\r\n    getCurrentResult(saveAsLastResult?: boolean): ApolloQueryResult<TData>;\r\n    isDifferentFromLastResult(newResult: ApolloQueryResult<TData>): boolean;\r\n    getLastResult(): ApolloQueryResult<TData>;\r\n    getLastError(): ApolloError;\r\n    resetLastResults(): void;\r\n    resetQueryStoreErrors(): void;\r\n    refetch(variables?: Partial<TVariables>): Promise<ApolloQueryResult<TData>>;\r\n    fetchMore<K extends keyof TVariables>(fetchMoreOptions: FetchMoreQueryOptions<TVariables, K, TData> & FetchMoreOptions<TData, TVariables>): Promise<ApolloQueryResult<TData>>;\r\n    subscribeToMore<TSubscriptionData = TData, TSubscriptionVariables = TVariables>(options: SubscribeToMoreOptions<TData, TSubscriptionVariables, TSubscriptionData>): () => void;\r\n    setOptions(newOptions: Partial<WatchQueryOptions<TVariables, TData>>): Promise<ApolloQueryResult<TData>>;\r\n    setVariables(variables: TVariables): Promise<ApolloQueryResult<TData> | void>;\r\n    updateQuery<TVars = TVariables>(mapFn: (previousQueryResult: TData, options: Pick<WatchQueryOptions<TVars, TData>, \"variables\">) => TData): void;\r\n    startPolling(pollInterval: number): void;\r\n    stopPolling(): void;\r\n    private updateLastResult;\r\n    private onSubscribe;\r\n    private reobserver?;\r\n    private getReobserver;\r\n    private newReobserver;\r\n    reobserve(newOptions?: Partial<WatchQueryOptions<TVariables, TData>>, newNetworkStatus?: NetworkStatus): Promise<ApolloQueryResult<TData>>;\r\n    private observe;\r\n    private observer;\r\n    hasObservers(): boolean;\r\n    private tearDownQuery;\r\n}\r\n",
      "@apollo/client/core/QueryInfo.d.ts": "/// <reference types=\"zen-observable\" />\r\nimport { DocumentNode, GraphQLError } from 'graphql';\r\nimport { Cache, ApolloCache } from '../cache';\r\nimport { WatchQueryOptions, ErrorPolicy } from './watchQueryOptions';\r\nimport { ObservableQuery } from './ObservableQuery';\r\nimport { QueryListener } from './types';\r\nimport { FetchResult } from '../link/core';\r\nimport { NetworkStatus } from './networkStatus';\r\nimport { ApolloError } from '../errors';\r\nexport declare type QueryStoreValue = Pick<QueryInfo, \"variables\" | \"networkStatus\" | \"networkError\" | \"graphQLErrors\">;\r\nexport declare class QueryInfo {\r\n    private cache;\r\n    listeners: Set<QueryListener>;\r\n    document: DocumentNode | null;\r\n    lastRequestId: number;\r\n    subscriptions: Set<ZenObservable.Subscription>;\r\n    variables?: Record<string, any>;\r\n    networkStatus?: NetworkStatus;\r\n    networkError?: Error | null;\r\n    graphQLErrors?: ReadonlyArray<GraphQLError>;\r\n    constructor(cache: ApolloCache<any>);\r\n    init(query: {\r\n        document: DocumentNode;\r\n        variables: Record<string, any> | undefined;\r\n        networkStatus?: NetworkStatus;\r\n        observableQuery?: ObservableQuery<any>;\r\n        lastRequestId?: number;\r\n    }): this;\r\n    private dirty;\r\n    private notifyTimeout?;\r\n    private diff;\r\n    getDiff(variables?: Record<string, any> | undefined): Cache.DiffResult<any>;\r\n    setDiff(diff: Cache.DiffResult<any> | null): void;\r\n    readonly observableQuery: ObservableQuery<any> | null;\r\n    private oqListener?;\r\n    setObservableQuery(oq: ObservableQuery<any> | null): void;\r\n    notify(): void;\r\n    private shouldNotify;\r\n    stop(): void;\r\n    private cancel;\r\n    private lastWatch?;\r\n    private updateWatch;\r\n    private lastWrite?;\r\n    private shouldWrite;\r\n    markResult<T>(result: FetchResult<T>, options: Pick<WatchQueryOptions, \"variables\" | \"fetchPolicy\" | \"errorPolicy\">, allowCacheWrite: boolean): void;\r\n    markReady(): NetworkStatus;\r\n    markError(error: ApolloError): ApolloError;\r\n}\r\nexport declare function shouldWriteResult<T>(result: FetchResult<T>, errorPolicy?: ErrorPolicy): boolean;\r\n",
      "@apollo/client/core/QueryManager.d.ts": "/// <reference types=\"zen-observable\" />\r\nimport { DocumentNode } from 'graphql';\r\nimport { ApolloLink, FetchResult } from '../link/core';\r\nimport { ApolloCache } from '../cache';\r\nimport { Observable, Concast } from '../utilities';\r\nimport { MutationStore } from './MutationStore';\r\nimport { QueryOptions, WatchQueryOptions, SubscriptionOptions, MutationOptions } from './watchQueryOptions';\r\nimport { ObservableQuery } from './ObservableQuery';\r\nimport { NetworkStatus } from './networkStatus';\r\nimport { ApolloQueryResult, OperationVariables } from './types';\r\nimport { LocalState } from './LocalState';\r\nimport { QueryInfo } from './QueryInfo';\r\nexport declare class QueryManager<TStore> {\r\n    cache: ApolloCache<TStore>;\r\n    link: ApolloLink;\r\n    mutationStore: MutationStore;\r\n    readonly assumeImmutableResults: boolean;\r\n    readonly ssrMode: boolean;\r\n    private queryDeduplication;\r\n    private clientAwareness;\r\n    private localState;\r\n    private onBroadcast;\r\n    private queries;\r\n    private fetchCancelFns;\r\n    constructor({ cache, link, queryDeduplication, onBroadcast, ssrMode, clientAwareness, localState, assumeImmutableResults, }: {\r\n        cache: ApolloCache<TStore>;\r\n        link: ApolloLink;\r\n        queryDeduplication?: boolean;\r\n        onBroadcast?: () => void;\r\n        ssrMode?: boolean;\r\n        clientAwareness?: Record<string, string>;\r\n        localState?: LocalState<TStore>;\r\n        assumeImmutableResults?: boolean;\r\n    });\r\n    stop(): void;\r\n    private cancelPendingFetches;\r\n    mutate<T>({ mutation, variables, optimisticResponse, updateQueries: updateQueriesByName, refetchQueries, awaitRefetchQueries, update: updateWithProxyFn, errorPolicy, fetchPolicy, context, }: MutationOptions): Promise<FetchResult<T>>;\r\n    fetchQuery<TData, TVars>(queryId: string, options: WatchQueryOptions<TVars, TData>, networkStatus?: NetworkStatus): Promise<ApolloQueryResult<TData>>;\r\n    getQueryStore(): Record<string, Pick<QueryInfo, \"variables\" | \"graphQLErrors\" | \"networkError\" | \"networkStatus\">>;\r\n    resetErrors(queryId: string): void;\r\n    private transformCache;\r\n    transform(document: DocumentNode): Readonly<{\r\n        document: Readonly<DocumentNode>;\r\n        hasClientExports: boolean;\r\n        hasForcedResolvers: boolean;\r\n        clientQuery: Readonly<DocumentNode> | null;\r\n        serverQuery: Readonly<DocumentNode> | null;\r\n        defaultVars: Readonly<Record<string, any>>;\r\n    }>;\r\n    private getVariables;\r\n    watchQuery<T, TVariables = OperationVariables>(options: WatchQueryOptions<TVariables, T>): ObservableQuery<T, TVariables>;\r\n    query<TData, TVars = OperationVariables>(options: QueryOptions<TVars, TData>): Promise<ApolloQueryResult<TData>>;\r\n    private queryIdCounter;\r\n    generateQueryId(): string;\r\n    private requestIdCounter;\r\n    generateRequestId(): number;\r\n    private mutationIdCounter;\r\n    generateMutationId(): string;\r\n    stopQueryInStore(queryId: string): void;\r\n    private stopQueryInStoreNoBroadcast;\r\n    clearStore(): Promise<void>;\r\n    resetStore(): Promise<ApolloQueryResult<any>[]>;\r\n    reFetchObservableQueries(includeStandby?: boolean): Promise<ApolloQueryResult<any>[]>;\r\n    setObservableQuery(observableQuery: ObservableQuery<any, any>): void;\r\n    startGraphQLSubscription<T = any>({ query, fetchPolicy, errorPolicy, variables, context, }: SubscriptionOptions): Observable<FetchResult<T>>;\r\n    stopQuery(queryId: string): void;\r\n    private stopQueryNoBroadcast;\r\n    removeQuery(queryId: string): void;\r\n    broadcastQueries(): void;\r\n    getLocalState(): LocalState<TStore>;\r\n    private inFlightLinkObservables;\r\n    private getObservableFromLink;\r\n    private getResultsFromLink;\r\n    fetchQueryObservable<TData, TVars>(queryId: string, options: WatchQueryOptions<TVars, TData>, networkStatus?: NetworkStatus): Concast<ApolloQueryResult<TData>>;\r\n    private fetchQueryByPolicy;\r\n    private getQuery;\r\n    private prepareContext;\r\n}\r\n",
      "@apollo/client/core/Reobserver.d.ts": "import { WatchQueryOptions } from './watchQueryOptions';\r\nimport { NetworkStatus } from './networkStatus';\r\nimport { ApolloQueryResult } from './types';\r\nimport { Observer, Concast } from '../utilities';\r\nexport declare class Reobserver<TData, TVars> {\r\n    private observer;\r\n    private options;\r\n    private fetch;\r\n    private shouldFetch;\r\n    constructor(observer: Observer<ApolloQueryResult<TData>>, options: WatchQueryOptions<TVars, TData>, fetch: (options: WatchQueryOptions<TVars, TData>, newNetworkStatus?: NetworkStatus) => Concast<ApolloQueryResult<TData>>, shouldFetch: false | (() => boolean));\r\n    private concast?;\r\n    reobserve(newOptions?: Partial<WatchQueryOptions<TVars, TData>>, newNetworkStatus?: NetworkStatus): Promise<ApolloQueryResult<TData>>;\r\n    updateOptions(newOptions: Partial<WatchQueryOptions<TVars, TData>>): this;\r\n    stop(): void;\r\n    private pollingInfo?;\r\n    private updatePolling;\r\n}\r\n",
      "@apollo/client/core/types.d.ts": "import { DocumentNode, GraphQLError } from 'graphql';\r\nimport { FetchResult } from '../link/core';\r\nimport { ApolloError } from '../errors';\r\nimport { QueryInfo } from './QueryInfo';\r\nimport { NetworkStatus } from './networkStatus';\r\nimport { Resolver } from './LocalState';\r\nexport { TypedDocumentNode } from '@graphql-typed-document-node/core';\r\nexport declare type QueryListener = (queryInfo: QueryInfo) => void;\r\nexport declare type OperationVariables = Record<string, any>;\r\nexport declare type PureQueryOptions = {\r\n    query: DocumentNode;\r\n    variables?: {\r\n        [key: string]: any;\r\n    };\r\n    context?: any;\r\n};\r\nexport declare type ApolloQueryResult<T> = {\r\n    data: T;\r\n    errors?: ReadonlyArray<GraphQLError>;\r\n    error?: ApolloError;\r\n    loading: boolean;\r\n    networkStatus: NetworkStatus;\r\n    partial?: boolean;\r\n};\r\nexport declare type MutationQueryReducer<T> = (previousResult: Record<string, any>, options: {\r\n    mutationResult: FetchResult<T>;\r\n    queryName: string | undefined;\r\n    queryVariables: Record<string, any>;\r\n}) => Record<string, any>;\r\nexport declare type MutationQueryReducersMap<T = {\r\n    [key: string]: any;\r\n}> = {\r\n    [queryName: string]: MutationQueryReducer<T>;\r\n};\r\nexport interface Resolvers {\r\n    [key: string]: {\r\n        [field: string]: Resolver;\r\n    };\r\n}\r\n",
      "@apollo/client/core/watchQueryOptions.d.ts": "import { DocumentNode } from 'graphql';\r\nimport { TypedDocumentNode } from '@graphql-typed-document-node/core';\r\nimport { ApolloCache } from '../cache';\r\nimport { FetchResult } from '../link/core';\r\nimport { MutationQueryReducersMap } from './types';\r\nimport { PureQueryOptions, OperationVariables } from './types';\r\nexport declare type FetchPolicy = 'cache-first' | 'network-only' | 'cache-only' | 'no-cache' | 'standby';\r\nexport declare type WatchQueryFetchPolicy = FetchPolicy | 'cache-and-network';\r\nexport declare type ErrorPolicy = 'none' | 'ignore' | 'all';\r\nexport interface QueryBaseOptions<TVariables = OperationVariables, TData = any> {\r\n    query: DocumentNode | TypedDocumentNode<TData, TVariables>;\r\n    variables?: TVariables;\r\n    errorPolicy?: ErrorPolicy;\r\n    context?: any;\r\n}\r\nexport interface QueryOptions<TVariables = OperationVariables, TData = any> extends QueryBaseOptions<TVariables, TData> {\r\n    fetchPolicy?: FetchPolicy;\r\n}\r\nexport interface ModifiableWatchQueryOptions<TVariables = OperationVariables, TData = any> extends QueryBaseOptions<TVariables, TData> {\r\n    pollInterval?: number;\r\n    notifyOnNetworkStatusChange?: boolean;\r\n    returnPartialData?: boolean;\r\n    partialRefetch?: boolean;\r\n}\r\nexport interface WatchQueryOptions<TVariables = OperationVariables, TData = any> extends QueryBaseOptions<TVariables, TData>, ModifiableWatchQueryOptions<TVariables, TData> {\r\n    fetchPolicy?: WatchQueryFetchPolicy;\r\n    nextFetchPolicy?: WatchQueryFetchPolicy | ((this: WatchQueryOptions<TVariables, TData>, lastFetchPolicy: WatchQueryFetchPolicy) => WatchQueryFetchPolicy);\r\n}\r\nexport interface FetchMoreQueryOptions<TVariables, K extends keyof TVariables, TData = any> {\r\n    query?: DocumentNode | TypedDocumentNode<TData, TVariables>;\r\n    variables?: Pick<TVariables, K>;\r\n    context?: any;\r\n}\r\nexport declare type UpdateQueryFn<TData = any, TSubscriptionVariables = OperationVariables, TSubscriptionData = TData> = (previousQueryResult: TData, options: {\r\n    subscriptionData: {\r\n        data: TSubscriptionData;\r\n    };\r\n    variables?: TSubscriptionVariables;\r\n}) => TData;\r\nexport declare type SubscribeToMoreOptions<TData = any, TSubscriptionVariables = OperationVariables, TSubscriptionData = TData> = {\r\n    document: DocumentNode | TypedDocumentNode<TSubscriptionData, TSubscriptionVariables>;\r\n    variables?: TSubscriptionVariables;\r\n    updateQuery?: UpdateQueryFn<TData, TSubscriptionVariables, TSubscriptionData>;\r\n    onError?: (error: Error) => void;\r\n    context?: Record<string, any>;\r\n};\r\nexport interface SubscriptionOptions<TVariables = OperationVariables, TData = any> {\r\n    query: DocumentNode | TypedDocumentNode<TData, TVariables>;\r\n    variables?: TVariables;\r\n    fetchPolicy?: FetchPolicy;\r\n    errorPolicy?: ErrorPolicy;\r\n    context?: Record<string, any>;\r\n}\r\nexport declare type RefetchQueryDescription = Array<string | PureQueryOptions>;\r\nexport interface MutationBaseOptions<T = {\r\n    [key: string]: any;\r\n}, TVariables = OperationVariables> {\r\n    optimisticResponse?: T | ((vars: TVariables) => T);\r\n    updateQueries?: MutationQueryReducersMap<T>;\r\n    refetchQueries?: ((result: FetchResult<T>) => RefetchQueryDescription) | RefetchQueryDescription;\r\n    awaitRefetchQueries?: boolean;\r\n    update?: MutationUpdaterFn<T>;\r\n    errorPolicy?: ErrorPolicy;\r\n    variables?: TVariables;\r\n}\r\nexport interface MutationOptions<T = {\r\n    [key: string]: any;\r\n}, TVariables = OperationVariables> extends MutationBaseOptions<T, TVariables> {\r\n    mutation: DocumentNode | TypedDocumentNode<T, TVariables>;\r\n    context?: any;\r\n    fetchPolicy?: Extract<FetchPolicy, 'no-cache'>;\r\n}\r\nexport declare type MutationUpdaterFn<T = {\r\n    [key: string]: any;\r\n}> = (cache: ApolloCache<T>, mutationResult: FetchResult<T>) => void;\r\n",
      "@apollo/client/errors/index.d.ts": "import { GraphQLError } from 'graphql';\r\nimport { ServerParseError } from '../link/http';\r\nimport { ServerError } from '../link/utils';\r\nexport declare function isApolloError(err: Error): err is ApolloError;\r\nexport declare class ApolloError extends Error {\r\n    message: string;\r\n    graphQLErrors: ReadonlyArray<GraphQLError>;\r\n    networkError: Error | ServerParseError | ServerError | null;\r\n    extraInfo: any;\r\n    constructor({ graphQLErrors, networkError, errorMessage, extraInfo, }: {\r\n        graphQLErrors?: ReadonlyArray<GraphQLError>;\r\n        networkError?: Error | ServerParseError | ServerError | null;\r\n        errorMessage?: string;\r\n        extraInfo?: any;\r\n    });\r\n}\r\n",
      "@apollo/client/index.d.ts": "export * from './core';\r\nexport * from './react';\r\n",
      "@apollo/client/link/batch/batching.d.ts": "/// <reference types=\"zen-observable\" />\r\nimport { Operation, FetchResult, NextLink } from '../core';\r\nimport { Observable } from '../../utilities';\r\nexport declare type BatchHandler = (operations: Operation[], forward?: (NextLink | undefined)[]) => Observable<FetchResult[]> | null;\r\nexport interface BatchableRequest {\r\n    operation: Operation;\r\n    forward?: NextLink;\r\n    observable?: Observable<FetchResult>;\r\n    next?: Array<(result: FetchResult) => void>;\r\n    error?: Array<(error: Error) => void>;\r\n    complete?: Array<() => void>;\r\n}\r\nexport declare class OperationBatcher {\r\n    queuedRequests: Map<string, BatchableRequest[]>;\r\n    private batchInterval?;\r\n    private batchMax;\r\n    private batchHandler;\r\n    private batchKey;\r\n    constructor({ batchInterval, batchMax, batchHandler, batchKey, }: {\r\n        batchInterval?: number;\r\n        batchMax?: number;\r\n        batchHandler: BatchHandler;\r\n        batchKey?: (operation: Operation) => string;\r\n    });\r\n    enqueueRequest(request: BatchableRequest): Observable<FetchResult>;\r\n    consumeQueue(key?: string): (Observable<FetchResult> | undefined)[] | undefined;\r\n    private scheduleQueueConsumption;\r\n}\r\n",
      "@apollo/client/link/batch/batchLink.d.ts": "/// <reference types=\"zen-observable\" />\r\nimport { ApolloLink, Operation, FetchResult, NextLink } from '../core';\r\nimport { Observable } from '../../utilities';\r\nimport { BatchHandler } from './batching';\r\nexport { OperationBatcher, BatchableRequest, BatchHandler } from './batching';\r\nexport declare namespace BatchLink {\r\n    interface Options {\r\n        batchInterval?: number;\r\n        batchMax?: number;\r\n        batchHandler?: BatchHandler;\r\n        batchKey?: (operation: Operation) => string;\r\n    }\r\n}\r\nexport declare class BatchLink extends ApolloLink {\r\n    private batcher;\r\n    constructor(fetchParams?: BatchLink.Options);\r\n    request(operation: Operation, forward?: NextLink): Observable<FetchResult> | null;\r\n}\r\n",
      "@apollo/client/link/batch/index.d.ts": "export * from './batchLink';\r\n",
      "@apollo/client/link/batch-http/batchHttpLink.d.ts": "/// <reference types=\"zen-observable\" />\r\nimport { ApolloLink, Operation, FetchResult } from '../core';\r\nimport { Observable } from '../../utilities';\r\nimport { HttpOptions } from '../http';\r\nexport declare namespace BatchHttpLink {\r\n    interface Options extends HttpOptions {\r\n        batchMax?: number;\r\n        batchInterval?: number;\r\n        batchKey?: (operation: Operation) => string;\r\n    }\r\n}\r\nexport declare class BatchHttpLink extends ApolloLink {\r\n    private batchInterval;\r\n    private batchMax;\r\n    private batcher;\r\n    constructor(fetchParams?: BatchHttpLink.Options);\r\n    request(operation: Operation): Observable<FetchResult> | null;\r\n}\r\n",
      "@apollo/client/link/batch-http/index.d.ts": "export * from './batchHttpLink';\r\n",
      "@apollo/client/link/context/index.d.ts": "import { ApolloLink, GraphQLRequest } from '../core';\r\nexport declare type ContextSetter = (operation: GraphQLRequest, prevContext: any) => Promise<any> | any;\r\nexport declare function setContext(setter: ContextSetter): ApolloLink;\r\n",
      "@apollo/client/link/core/ApolloLink.d.ts": "/// <reference types=\"zen-observable\" />\r\nimport { Observable } from '../../utilities';\r\nimport { NextLink, Operation, RequestHandler, FetchResult, GraphQLRequest } from './types';\r\nexport declare class ApolloLink {\r\n    static empty(): ApolloLink;\r\n    static from(links: (ApolloLink | RequestHandler)[]): ApolloLink;\r\n    static split(test: (op: Operation) => boolean, left: ApolloLink | RequestHandler, right?: ApolloLink | RequestHandler): ApolloLink;\r\n    static execute(link: ApolloLink, operation: GraphQLRequest): Observable<FetchResult>;\r\n    static concat(first: ApolloLink | RequestHandler, second: ApolloLink | RequestHandler): ApolloLink;\r\n    constructor(request?: RequestHandler);\r\n    split(test: (op: Operation) => boolean, left: ApolloLink | RequestHandler, right?: ApolloLink | RequestHandler): ApolloLink;\r\n    concat(next: ApolloLink | RequestHandler): ApolloLink;\r\n    request(operation: Operation, forward?: NextLink): Observable<FetchResult> | null;\r\n    protected onError(reason: any): void;\r\n    setOnError(fn: (reason: any) => any): this;\r\n}\r\n",
      "@apollo/client/link/core/concat.d.ts": "import { ApolloLink } from './ApolloLink';\r\nexport declare const concat: typeof ApolloLink.concat;\r\n",
      "@apollo/client/link/core/empty.d.ts": "import { ApolloLink } from './ApolloLink';\r\nexport declare const empty: typeof ApolloLink.empty;\r\n",
      "@apollo/client/link/core/execute.d.ts": "import { ApolloLink } from './ApolloLink';\r\nexport declare const execute: typeof ApolloLink.execute;\r\n",
      "@apollo/client/link/core/from.d.ts": "import { ApolloLink } from './ApolloLink';\r\nexport declare const from: typeof ApolloLink.from;\r\n",
      "@apollo/client/link/core/index.d.ts": "export { empty } from './empty';\r\nexport { from } from './from';\r\nexport { split } from './split';\r\nexport { concat } from './concat';\r\nexport { execute } from './execute';\r\nexport { ApolloLink } from './ApolloLink';\r\nexport * from './types';\r\n",
      "@apollo/client/link/core/split.d.ts": "import { ApolloLink } from './ApolloLink';\r\nexport declare const split: typeof ApolloLink.split;\r\n",
      "@apollo/client/link/core/types.d.ts": "/// <reference types=\"zen-observable\" />\r\nimport { DocumentNode, ExecutionResult } from 'graphql';\r\nexport { DocumentNode };\r\nimport { Observable } from '../../utilities';\r\nexport interface GraphQLRequest {\r\n    query: DocumentNode;\r\n    variables?: Record<string, any>;\r\n    operationName?: string;\r\n    context?: Record<string, any>;\r\n    extensions?: Record<string, any>;\r\n}\r\nexport interface Operation {\r\n    query: DocumentNode;\r\n    variables: Record<string, any>;\r\n    operationName: string;\r\n    extensions: Record<string, any>;\r\n    setContext: (context: Record<string, any>) => Record<string, any>;\r\n    getContext: () => Record<string, any>;\r\n}\r\nexport interface FetchResult<TData = {\r\n    [key: string]: any;\r\n}, C = Record<string, any>, E = Record<string, any>> extends ExecutionResult {\r\n    data?: TData | null;\r\n    extensions?: E;\r\n    context?: C;\r\n}\r\nexport declare type NextLink = (operation: Operation) => Observable<FetchResult>;\r\nexport declare type RequestHandler = (operation: Operation, forward: NextLink) => Observable<FetchResult> | null;\r\n",
      "@apollo/client/link/error/index.d.ts": "/// <reference types=\"zen-observable\" />\r\nimport { GraphQLError, ExecutionResult } from 'graphql';\r\nimport { ApolloLink, Operation, FetchResult, NextLink } from '../core';\r\nimport { Observable } from '../../utilities';\r\nimport { ServerError } from '../utils';\r\nimport { ServerParseError } from '../http';\r\nexport interface ErrorResponse {\r\n    graphQLErrors?: ReadonlyArray<GraphQLError>;\r\n    networkError?: Error | ServerError | ServerParseError;\r\n    response?: ExecutionResult;\r\n    operation: Operation;\r\n    forward: NextLink;\r\n}\r\nexport declare namespace ErrorLink {\r\n    interface ErrorHandler {\r\n        (error: ErrorResponse): Observable<FetchResult> | void;\r\n    }\r\n}\r\nexport import ErrorHandler = ErrorLink.ErrorHandler;\r\nexport declare function onError(errorHandler: ErrorHandler): ApolloLink;\r\nexport declare class ErrorLink extends ApolloLink {\r\n    private link;\r\n    constructor(errorHandler: ErrorLink.ErrorHandler);\r\n    request(operation: Operation, forward: NextLink): Observable<FetchResult> | null;\r\n}\r\n",
      "@apollo/client/link/http/checkFetcher.d.ts": "export declare const checkFetcher: (fetcher: WindowOrWorkerGlobalScope['fetch'] | undefined) => void;\r\n",
      "@apollo/client/link/http/createHttpLink.d.ts": "import { ApolloLink } from '../core';\r\nimport { HttpOptions } from './selectHttpOptionsAndBody';\r\nexport declare const createHttpLink: (linkOptions?: HttpOptions) => ApolloLink;\r\n",
      "@apollo/client/link/http/createSignalIfSupported.d.ts": "export declare const createSignalIfSupported: () => {\r\n    controller: boolean;\r\n    signal: boolean;\r\n} | {\r\n    controller: AbortController;\r\n    signal: AbortSignal;\r\n};\r\n",
      "@apollo/client/link/http/HttpLink.d.ts": "import { ApolloLink, RequestHandler } from '../core';\r\nimport { HttpOptions } from './selectHttpOptionsAndBody';\r\nexport declare class HttpLink extends ApolloLink {\r\n    options: HttpOptions;\r\n    requester: RequestHandler;\r\n    constructor(options?: HttpOptions);\r\n}\r\n",
      "@apollo/client/link/http/index.d.ts": "export { parseAndCheckHttpResponse, ServerParseError } from './parseAndCheckHttpResponse';\r\nexport { serializeFetchParameter, ClientParseError } from './serializeFetchParameter';\r\nexport { HttpOptions, fallbackHttpConfig, selectHttpOptionsAndBody, UriFunction } from './selectHttpOptionsAndBody';\r\nexport { checkFetcher } from './checkFetcher';\r\nexport { createSignalIfSupported } from './createSignalIfSupported';\r\nexport { selectURI } from './selectURI';\r\nexport { createHttpLink } from './createHttpLink';\r\nexport { HttpLink } from './HttpLink';\r\nexport { rewriteURIForGET } from './rewriteURIForGET';\r\n",
      "@apollo/client/link/http/parseAndCheckHttpResponse.d.ts": "import { Operation } from '../core';\r\nexport declare type ServerParseError = Error & {\r\n    response: Response;\r\n    statusCode: number;\r\n    bodyText: string;\r\n};\r\nexport declare function parseAndCheckHttpResponse(operations: Operation | Operation[]): (response: Response) => Promise<any>;\r\n",
      "@apollo/client/link/http/rewriteURIForGET.d.ts": "import { Body } from './selectHttpOptionsAndBody';\r\nexport declare function rewriteURIForGET(chosenURI: string, body: Body): {\r\n    parseError: any;\r\n    newURI?: undefined;\r\n} | {\r\n    newURI: string;\r\n    parseError?: undefined;\r\n};\r\n",
      "@apollo/client/link/http/selectHttpOptionsAndBody.d.ts": "import { Operation } from '../core';\r\nexport interface UriFunction {\r\n    (operation: Operation): string;\r\n}\r\nexport interface Body {\r\n    query?: string;\r\n    operationName?: string;\r\n    variables?: Record<string, any>;\r\n    extensions?: Record<string, any>;\r\n}\r\nexport interface HttpOptions {\r\n    uri?: string | UriFunction;\r\n    includeExtensions?: boolean;\r\n    fetch?: WindowOrWorkerGlobalScope['fetch'];\r\n    headers?: any;\r\n    credentials?: string;\r\n    fetchOptions?: any;\r\n    useGETForQueries?: boolean;\r\n}\r\nexport interface HttpQueryOptions {\r\n    includeQuery?: boolean;\r\n    includeExtensions?: boolean;\r\n}\r\nexport interface HttpConfig {\r\n    http?: HttpQueryOptions;\r\n    options?: any;\r\n    headers?: any;\r\n    credentials?: any;\r\n}\r\nexport declare const fallbackHttpConfig: {\r\n    http: HttpQueryOptions;\r\n    headers: {\r\n        accept: string;\r\n        'content-type': string;\r\n    };\r\n    options: {\r\n        method: string;\r\n    };\r\n};\r\nexport declare const selectHttpOptionsAndBody: (operation: Operation, fallbackConfig: HttpConfig, ...configs: Array<HttpConfig>) => {\r\n    options: HttpConfig & Record<string, any>;\r\n    body: Body;\r\n};\r\n",
      "@apollo/client/link/http/selectURI.d.ts": "import { Operation } from '../core';\r\nexport declare const selectURI: (operation: Operation, fallbackURI?: string | ((operation: Operation) => string) | undefined) => any;\r\n",
      "@apollo/client/link/http/serializeFetchParameter.d.ts": "import { InvariantError } from 'ts-invariant';\r\nexport declare type ClientParseError = InvariantError & {\r\n    parseError: Error;\r\n};\r\nexport declare const serializeFetchParameter: (p: any, label: string) => string;\r\n",
      "@apollo/client/link/persisted-queries/index.d.ts": "import { DocumentNode, ExecutionResult, GraphQLError } from 'graphql';\r\nimport { ApolloLink, Operation } from '../core';\r\nexport declare const VERSION = 1;\r\nexport interface ErrorResponse {\r\n    graphQLErrors?: readonly GraphQLError[];\r\n    networkError?: Error;\r\n    response?: ExecutionResult;\r\n    operation: Operation;\r\n}\r\ndeclare type SHA256Function = (...args: any[]) => string | PromiseLike<string>;\r\ndeclare type GenerateHashFunction = (document: DocumentNode) => string | PromiseLike<string>;\r\ndeclare namespace PersistedQueryLink {\r\n    interface BaseOptions {\r\n        disable?: (error: ErrorResponse) => boolean;\r\n        useGETForHashedQueries?: boolean;\r\n    }\r\n    interface SHA256Options extends BaseOptions {\r\n        sha256: SHA256Function;\r\n        generateHash?: never;\r\n    }\r\n    interface GenerateHashOptions extends BaseOptions {\r\n        sha256?: never;\r\n        generateHash: GenerateHashFunction;\r\n    }\r\n    export type Options = SHA256Options | GenerateHashOptions;\r\n    export {};\r\n}\r\nexport declare const createPersistedQueryLink: (options: PersistedQueryLink.Options) => ApolloLink;\r\nexport {};\r\n",
      "@apollo/client/link/retry/delayFunction.d.ts": "import { Operation } from '../core';\r\nexport interface DelayFunction {\r\n    (count: number, operation: Operation, error: any): number;\r\n}\r\nexport interface DelayFunctionOptions {\r\n    initial?: number;\r\n    max?: number;\r\n    jitter?: boolean;\r\n}\r\nexport declare function buildDelayFunction(delayOptions?: DelayFunctionOptions): DelayFunction;\r\n",
      "@apollo/client/link/retry/index.d.ts": "export * from './retryLink';\r\n",
      "@apollo/client/link/retry/retryFunction.d.ts": "import { Operation } from '../core';\r\nexport interface RetryFunction {\r\n    (count: number, operation: Operation, error: any): boolean | Promise<boolean>;\r\n}\r\nexport interface RetryFunctionOptions {\r\n    max?: number;\r\n    retryIf?: (error: any, operation: Operation) => boolean | Promise<boolean>;\r\n}\r\nexport declare function buildRetryFunction(retryOptions?: RetryFunctionOptions): RetryFunction;\r\n",
      "@apollo/client/link/retry/retryLink.d.ts": "/// <reference types=\"zen-observable\" />\r\nimport { ApolloLink, Operation, FetchResult, NextLink } from '../core';\r\nimport { Observable } from '../../utilities';\r\nimport { DelayFunction, DelayFunctionOptions } from './delayFunction';\r\nimport { RetryFunction, RetryFunctionOptions } from './retryFunction';\r\nexport declare namespace RetryLink {\r\n    interface Options {\r\n        delay?: DelayFunctionOptions | DelayFunction;\r\n        attempts?: RetryFunctionOptions | RetryFunction;\r\n    }\r\n}\r\nexport declare class RetryLink extends ApolloLink {\r\n    private delayFor;\r\n    private retryIf;\r\n    constructor(options?: RetryLink.Options);\r\n    request(operation: Operation, nextLink: NextLink): Observable<FetchResult>;\r\n}\r\n",
      "@apollo/client/link/schema/index.d.ts": "/// <reference types=\"zen-observable\" />\r\nimport { GraphQLSchema } from 'graphql';\r\nimport { ApolloLink, Operation, FetchResult } from '../core';\r\nimport { Observable } from '../../utilities';\r\nexport declare namespace SchemaLink {\r\n    type ResolverContext = Record<string, any>;\r\n    type ResolverContextFunction = (operation: Operation) => ResolverContext | PromiseLike<ResolverContext>;\r\n    interface Options {\r\n        schema: GraphQLSchema;\r\n        rootValue?: any;\r\n        context?: ResolverContext | ResolverContextFunction;\r\n    }\r\n}\r\nexport declare class SchemaLink extends ApolloLink {\r\n    schema: SchemaLink.Options[\"schema\"];\r\n    rootValue: SchemaLink.Options[\"rootValue\"];\r\n    context: SchemaLink.Options[\"context\"];\r\n    constructor(options: SchemaLink.Options);\r\n    request(operation: Operation): Observable<FetchResult>;\r\n}\r\n",
      "@apollo/client/link/utils/createOperation.d.ts": "import { GraphQLRequest, Operation } from '../core';\r\nexport declare function createOperation(starting: any, operation: GraphQLRequest): Operation;\r\n",
      "@apollo/client/link/utils/fromError.d.ts": "/// <reference types=\"zen-observable\" />\r\nimport { Observable } from '../../utilities';\r\nexport declare function fromError<T>(errorValue: any): Observable<T>;\r\n",
      "@apollo/client/link/utils/fromPromise.d.ts": "/// <reference types=\"zen-observable\" />\r\nimport { Observable } from '../../utilities';\r\nexport declare function fromPromise<T>(promise: Promise<T>): Observable<T>;\r\n",
      "@apollo/client/link/utils/index.d.ts": "export { fromError } from './fromError';\r\nexport { toPromise } from './toPromise';\r\nexport { fromPromise } from './fromPromise';\r\nexport { ServerError, throwServerError } from './throwServerError';\r\nexport { validateOperation } from './validateOperation';\r\nexport { createOperation } from './createOperation';\r\nexport { transformOperation } from './transformOperation';\r\n",
      "@apollo/client/link/utils/throwServerError.d.ts": "export declare type ServerError = Error & {\r\n    response: Response;\r\n    result: Record<string, any>;\r\n    statusCode: number;\r\n};\r\nexport declare const throwServerError: (response: Response, result: any, message: string) => never;\r\n",
      "@apollo/client/link/utils/toPromise.d.ts": "/// <reference types=\"zen-observable\" />\r\nimport { Observable } from '../../utilities';\r\nexport declare function toPromise<R>(observable: Observable<R>): Promise<R>;\r\n",
      "@apollo/client/link/utils/transformOperation.d.ts": "import { GraphQLRequest } from '../core';\r\nexport declare function transformOperation(operation: GraphQLRequest): GraphQLRequest;\r\n",
      "@apollo/client/link/utils/validateOperation.d.ts": "import { GraphQLRequest } from '../core';\r\nexport declare function validateOperation(operation: GraphQLRequest): GraphQLRequest;\r\n",
      "@apollo/client/link/ws/index.d.ts": "/// <reference types=\"zen-observable\" />\r\nimport { SubscriptionClient, ClientOptions } from 'subscriptions-transport-ws';\r\nimport { ApolloLink, Operation, FetchResult } from '../core';\r\nimport { Observable } from '../../utilities';\r\nexport declare namespace WebSocketLink {\r\n    interface Configuration {\r\n        uri: string;\r\n        options?: ClientOptions;\r\n        webSocketImpl?: any;\r\n    }\r\n}\r\nexport import WebSocketParams = WebSocketLink.Configuration;\r\nexport declare class WebSocketLink extends ApolloLink {\r\n    private subscriptionClient;\r\n    constructor(paramsOrClient: WebSocketLink.Configuration | SubscriptionClient);\r\n    request(operation: Operation): Observable<FetchResult> | null;\r\n}\r\n",
      "@apollo/client/react/components/index.d.ts": "export { Query } from './Query';\r\nexport { Mutation } from './Mutation';\r\nexport { Subscription } from './Subscription';\r\nexport * from './types';\r\n",
      "@apollo/client/react/components/Mutation.d.ts": "/// <reference types=\"react\" />\r\nimport PropTypes from 'prop-types';\r\nimport { OperationVariables } from '../../core';\r\nimport { MutationComponentOptions } from './types';\r\nexport declare function Mutation<TData = any, TVariables = OperationVariables>(props: MutationComponentOptions<TData, TVariables>): JSX.Element | null;\r\nexport declare namespace Mutation {\r\n    var propTypes: {\r\n        mutation: PropTypes.Validator<object>;\r\n        variables: PropTypes.Requireable<object>;\r\n        optimisticResponse: PropTypes.Requireable<object>;\r\n        refetchQueries: PropTypes.Requireable<((...args: any[]) => any) | (string | object | null | undefined)[]>;\r\n        awaitRefetchQueries: PropTypes.Requireable<boolean>;\r\n        update: PropTypes.Requireable<(...args: any[]) => any>;\r\n        children: PropTypes.Validator<(...args: any[]) => any>;\r\n        onCompleted: PropTypes.Requireable<(...args: any[]) => any>;\r\n        onError: PropTypes.Requireable<(...args: any[]) => any>;\r\n        fetchPolicy: PropTypes.Requireable<string>;\r\n    };\r\n}\r\nexport interface Mutation<TData, TVariables> {\r\n    propTypes: PropTypes.InferProps<MutationComponentOptions<TData, TVariables>>;\r\n}\r\n",
      "@apollo/client/react/components/Query.d.ts": "/// <reference types=\"react\" />\r\nimport PropTypes from 'prop-types';\r\nimport { OperationVariables } from '../../core';\r\nimport { QueryComponentOptions } from './types';\r\nexport declare function Query<TData = any, TVariables = OperationVariables>(props: QueryComponentOptions<TData, TVariables>): JSX.Element | null;\r\nexport declare namespace Query {\r\n    var propTypes: {\r\n        client: PropTypes.Requireable<object>;\r\n        children: PropTypes.Validator<(...args: any[]) => any>;\r\n        fetchPolicy: PropTypes.Requireable<string>;\r\n        notifyOnNetworkStatusChange: PropTypes.Requireable<boolean>;\r\n        onCompleted: PropTypes.Requireable<(...args: any[]) => any>;\r\n        onError: PropTypes.Requireable<(...args: any[]) => any>;\r\n        pollInterval: PropTypes.Requireable<number>;\r\n        query: PropTypes.Validator<object>;\r\n        variables: PropTypes.Requireable<object>;\r\n        ssr: PropTypes.Requireable<boolean>;\r\n        partialRefetch: PropTypes.Requireable<boolean>;\r\n        returnPartialData: PropTypes.Requireable<boolean>;\r\n    };\r\n}\r\nexport interface Query<TData, TVariables> {\r\n    propTypes: PropTypes.InferProps<QueryComponentOptions<TData, TVariables>>;\r\n}\r\n",
      "@apollo/client/react/components/Subscription.d.ts": "/// <reference types=\"react\" />\r\nimport PropTypes from 'prop-types';\r\nimport { OperationVariables } from '../../core';\r\nimport { SubscriptionComponentOptions } from './types';\r\nexport declare function Subscription<TData = any, TVariables = OperationVariables>(props: SubscriptionComponentOptions<TData, TVariables>): JSX.Element | null;\r\nexport declare namespace Subscription {\r\n    var propTypes: {\r\n        subscription: PropTypes.Validator<object>;\r\n        variables: PropTypes.Requireable<object>;\r\n        children: PropTypes.Requireable<(...args: any[]) => any>;\r\n        onSubscriptionData: PropTypes.Requireable<(...args: any[]) => any>;\r\n        onSubscriptionComplete: PropTypes.Requireable<(...args: any[]) => any>;\r\n        shouldResubscribe: PropTypes.Requireable<boolean | ((...args: any[]) => any)>;\r\n    };\r\n}\r\nexport interface Subscription<TData, TVariables> {\r\n    propTypes: PropTypes.InferProps<SubscriptionComponentOptions<TData, TVariables>>;\r\n}\r\n",
      "@apollo/client/react/components/types.d.ts": "/// <reference types=\"react\" />\r\nimport { DocumentNode } from 'graphql';\r\nimport { TypedDocumentNode } from '@graphql-typed-document-node/core';\r\nimport { OperationVariables } from '../../core';\r\nimport { QueryFunctionOptions, QueryResult, BaseMutationOptions, MutationFunction, MutationResult, BaseSubscriptionOptions, SubscriptionResult } from '../types/types';\r\nexport interface QueryComponentOptions<TData = any, TVariables = OperationVariables> extends QueryFunctionOptions<TData, TVariables> {\r\n    children: (result: QueryResult<TData, TVariables>) => JSX.Element | null;\r\n    query: DocumentNode | TypedDocumentNode<TData, TVariables>;\r\n}\r\nexport interface MutationComponentOptions<TData = any, TVariables = OperationVariables> extends BaseMutationOptions<TData, TVariables> {\r\n    mutation: DocumentNode | TypedDocumentNode<TData, TVariables>;\r\n    children: (mutateFunction: MutationFunction<TData, TVariables>, result: MutationResult<TData>) => JSX.Element | null;\r\n}\r\nexport interface SubscriptionComponentOptions<TData = any, TVariables = OperationVariables> extends BaseSubscriptionOptions<TData, TVariables> {\r\n    subscription: DocumentNode | TypedDocumentNode<TData, TVariables>;\r\n    children?: null | ((result: SubscriptionResult<TData>) => JSX.Element | null);\r\n}\r\n",
      "@apollo/client/react/context/ApolloConsumer.d.ts": "import React from 'react';\r\nimport { ApolloClient } from '../../core';\r\nexport interface ApolloConsumerProps {\r\n    children: (client: ApolloClient<object>) => React.ReactChild | null;\r\n}\r\nexport declare const ApolloConsumer: React.FC<ApolloConsumerProps>;\r\n",
      "@apollo/client/react/context/ApolloContext.d.ts": "import React from 'react';\r\nimport { ApolloClient } from '../../core';\r\nexport interface ApolloContextValue {\r\n    client?: ApolloClient<object>;\r\n    renderPromises?: Record<any, any>;\r\n}\r\nexport declare function resetApolloContext(): void;\r\nexport declare function getApolloContext(): React.Context<ApolloContextValue>;\r\n",
      "@apollo/client/react/context/ApolloProvider.d.ts": "import React from 'react';\r\nimport { ApolloClient } from '../../core';\r\nexport interface ApolloProviderProps<TCache> {\r\n    client: ApolloClient<TCache>;\r\n    children: React.ReactNode | React.ReactNode[] | null;\r\n}\r\nexport declare const ApolloProvider: React.FC<ApolloProviderProps<any>>;\r\n",
      "@apollo/client/react/context/index.d.ts": "export * from './ApolloConsumer';\r\nexport * from './ApolloContext';\r\nexport * from './ApolloProvider';\r\n",
      "@apollo/client/react/data/index.d.ts": "export { SubscriptionData } from './SubscriptionData';\r\nexport { OperationData } from './OperationData';\r\nexport { MutationData } from './MutationData';\r\nexport { QueryData } from './QueryData';\r\n",
      "@apollo/client/react/data/MutationData.d.ts": "import { MutationDataOptions, MutationTuple, MutationResult } from '../types/types';\r\nimport { OperationData } from './OperationData';\r\nimport { OperationVariables } from '../../core';\r\ndeclare type MutationResultWithoutClient<TData = any> = Omit<MutationResult<TData>, 'client'>;\r\nexport declare class MutationData<TData = any, TVariables = OperationVariables> extends OperationData {\r\n    private mostRecentMutationId;\r\n    private result;\r\n    private previousResult?;\r\n    private setResult;\r\n    constructor({ options, context, result, setResult }: {\r\n        options: MutationDataOptions<TData, TVariables>;\r\n        context: any;\r\n        result: MutationResultWithoutClient<TData>;\r\n        setResult: (result: MutationResultWithoutClient<TData>) => any;\r\n    });\r\n    execute(result: MutationResultWithoutClient<TData>): MutationTuple<TData, TVariables>;\r\n    afterExecute(): any;\r\n    cleanup(): void;\r\n    private runMutation;\r\n    private mutate;\r\n    private onMutationStart;\r\n    private onMutationCompleted;\r\n    private onMutationError;\r\n    private generateNewMutationId;\r\n    private isMostRecentMutation;\r\n    private updateResult;\r\n}\r\nexport {};\r\n",
      "@apollo/client/react/data/OperationData.d.ts": "import { DocumentNode } from 'graphql';\r\nimport { ApolloClient } from '../../core';\r\nimport { DocumentType } from '../parser';\r\nimport { CommonOptions } from '../types/types';\r\nexport declare abstract class OperationData<TOptions = any> {\r\n    isMounted: boolean;\r\n    previousOptions: CommonOptions<TOptions>;\r\n    context: any;\r\n    client: ApolloClient<object> | undefined;\r\n    private options;\r\n    constructor(options?: CommonOptions<TOptions>, context?: any);\r\n    getOptions(): CommonOptions<TOptions>;\r\n    setOptions(newOptions: CommonOptions<TOptions>, storePrevious?: boolean): void;\r\n    abstract execute(...args: any): any;\r\n    abstract afterExecute(...args: any): void | (() => void);\r\n    abstract cleanup(): void;\r\n    protected unmount(): void;\r\n    protected refreshClient(): {\r\n        client: ApolloClient<object>;\r\n        isNew: boolean;\r\n    };\r\n    protected verifyDocumentType(document: DocumentNode, type: DocumentType): void;\r\n}\r\n",
      "@apollo/client/react/data/QueryData.d.ts": "import { QueryResult, QueryDataOptions, QueryTuple } from '../types/types';\r\nimport { OperationData } from './OperationData';\r\nexport declare class QueryData<TData, TVariables> extends OperationData {\r\n    onNewData: () => void;\r\n    private previousData;\r\n    private currentObservable?;\r\n    private currentSubscription?;\r\n    private runLazy;\r\n    private lazyOptions?;\r\n    constructor({ options, context, onNewData }: {\r\n        options: QueryDataOptions<TData, TVariables>;\r\n        context: any;\r\n        onNewData: () => void;\r\n    });\r\n    execute(): QueryResult<TData, TVariables>;\r\n    executeLazy(): QueryTuple<TData, TVariables>;\r\n    fetchData(): Promise<void> | boolean;\r\n    afterExecute({ lazy }?: {\r\n        lazy?: boolean;\r\n    }): any;\r\n    cleanup(): void;\r\n    getOptions(): any;\r\n    ssrInitiated(): any;\r\n    private runLazyQuery;\r\n    private getExecuteResult;\r\n    private getExecuteSsrResult;\r\n    private prepareObservableQueryOptions;\r\n    private initializeObservableQuery;\r\n    private updateObservableQuery;\r\n    private startQuerySubscription;\r\n    private resubscribeToQuery;\r\n    private getQueryResult;\r\n    private handleErrorOrCompleted;\r\n    private removeQuerySubscription;\r\n    private obsRefetch;\r\n    private obsFetchMore;\r\n    private obsUpdateQuery;\r\n    private obsStartPolling;\r\n    private obsStopPolling;\r\n    private obsSubscribeToMore;\r\n    private observableQueryFields;\r\n}\r\n",
      "@apollo/client/react/data/SubscriptionData.d.ts": "import { OperationData } from './OperationData';\r\nimport { SubscriptionDataOptions, SubscriptionResult } from '../types/types';\r\nexport declare class SubscriptionData<TData = any, TVariables = any> extends OperationData<SubscriptionDataOptions<TData, TVariables>> {\r\n    private setResult;\r\n    private currentObservable;\r\n    constructor({ options, context, setResult }: {\r\n        options: SubscriptionDataOptions<TData, TVariables>;\r\n        context: any;\r\n        setResult: any;\r\n    });\r\n    execute(result: SubscriptionResult<TData>): {\r\n        variables: TVariables | undefined;\r\n        loading: boolean;\r\n        data?: TData | undefined;\r\n        error?: import(\"../..\").ApolloError | undefined;\r\n    };\r\n    afterExecute(): void;\r\n    cleanup(): void;\r\n    private initialize;\r\n    private startSubscription;\r\n    private getLoadingResult;\r\n    private updateResult;\r\n    private updateCurrentData;\r\n    private updateError;\r\n    private completeSubscription;\r\n    private endSubscription;\r\n}\r\n",
      "@apollo/client/react/hoc/graphql.d.ts": "/// <reference types=\"react\" />\r\nimport { DocumentNode } from 'graphql';\r\nimport { OperationOption, DataProps, MutateProps } from './types';\r\nexport declare function graphql<TProps extends TGraphQLVariables | {} = {}, TData = {}, TGraphQLVariables = {}, TChildProps = Partial<DataProps<TData, TGraphQLVariables>> & Partial<MutateProps<TData, TGraphQLVariables>>>(document: DocumentNode, operationOptions?: OperationOption<TProps, TData, TGraphQLVariables, TChildProps>): (WrappedComponent: React.ComponentType<TProps & TChildProps>) => React.ComponentClass<TProps>;\r\n",
      "@apollo/client/react/hoc/hoc-utils.d.ts": "import React from 'react';\r\nimport { IDocumentDefinition } from '../parser';\r\nexport declare const defaultMapPropsToOptions: () => {};\r\nexport declare const defaultMapResultToProps: <P>(props: P) => P;\r\nexport declare const defaultMapPropsToSkip: () => boolean;\r\nexport declare function getDisplayName<P>(WrappedComponent: React.ComponentType<P>): string;\r\nexport declare function calculateVariablesFromProps<TProps>(operation: IDocumentDefinition, props: TProps): Record<string, any>;\r\nexport declare type RefSetter<TChildProps> = (ref: React.ComponentClass<TChildProps>) => void | void;\r\nexport declare class GraphQLBase<TProps, TChildProps, TState = any> extends React.Component<TProps, TState> {\r\n    withRef: boolean;\r\n    private wrappedInstance?;\r\n    constructor(props: TProps);\r\n    getWrappedInstance(): React.ComponentClass<TChildProps, any> | undefined;\r\n    setWrappedInstance(ref: React.ComponentClass<TChildProps>): void;\r\n}\r\n",
      "@apollo/client/react/hoc/index.d.ts": "export { graphql } from './graphql';\r\nexport { withQuery } from './query-hoc';\r\nexport { withMutation } from './mutation-hoc';\r\nexport { withSubscription } from './subscription-hoc';\r\nexport { withApollo } from './withApollo';\r\nexport * from './types';\r\n",
      "@apollo/client/react/hoc/mutation-hoc.d.ts": "import React from 'react';\r\nimport { DocumentNode } from 'graphql';\r\nimport { OperationOption, MutateProps } from './types';\r\nexport declare function withMutation<TProps extends TGraphQLVariables | {} = {}, TData = {}, TGraphQLVariables = {}, TChildProps = MutateProps<TData, TGraphQLVariables>>(document: DocumentNode, operationOptions?: OperationOption<TProps, TData, TGraphQLVariables, TChildProps>): (WrappedComponent: React.ComponentType<TProps & TChildProps>) => React.ComponentClass<TProps>;\r\n",
      "@apollo/client/react/hoc/query-hoc.d.ts": "import React from 'react';\r\nimport { DocumentNode } from 'graphql';\r\nimport { OperationOption, DataProps } from './types';\r\nexport declare function withQuery<TProps extends TGraphQLVariables | {} = {}, TData = {}, TGraphQLVariables = {}, TChildProps = DataProps<TData, TGraphQLVariables>>(document: DocumentNode, operationOptions?: OperationOption<TProps, TData, TGraphQLVariables, TChildProps>): (WrappedComponent: React.ComponentType<TProps & TChildProps>) => React.ComponentClass<TProps>;\r\n",
      "@apollo/client/react/hoc/subscription-hoc.d.ts": "import React from 'react';\r\nimport { DocumentNode } from 'graphql';\r\nimport { OperationOption, DataProps } from './types';\r\nexport declare function withSubscription<TProps extends TGraphQLVariables | {} = {}, TData = {}, TGraphQLVariables = {}, TChildProps = DataProps<TData, TGraphQLVariables>>(document: DocumentNode, operationOptions?: OperationOption<TProps, TData, TGraphQLVariables, TChildProps>): (WrappedComponent: React.ComponentType<TProps & TChildProps>) => React.ComponentClass<TProps>;\r\n",
      "@apollo/client/react/hoc/types.d.ts": "import { ApolloClient } from '../../core';\r\nimport { ApolloError } from '../../errors';\r\nimport { ApolloQueryResult, OperationVariables, FetchMoreOptions, UpdateQueryOptions, FetchMoreQueryOptions, SubscribeToMoreOptions } from '../../core';\r\nimport { MutationFunction, BaseQueryOptions, BaseMutationOptions, MutationResult } from '../types/types';\r\nexport interface QueryControls<TData = any, TGraphQLVariables = OperationVariables> {\r\n    error?: ApolloError;\r\n    networkStatus: number;\r\n    loading: boolean;\r\n    variables: TGraphQLVariables;\r\n    fetchMore: (fetchMoreOptions: FetchMoreQueryOptions<TGraphQLVariables, any, TData> & FetchMoreOptions<TData, TGraphQLVariables>) => Promise<ApolloQueryResult<TData>>;\r\n    refetch: (variables?: TGraphQLVariables) => Promise<ApolloQueryResult<TData>>;\r\n    startPolling: (pollInterval: number) => void;\r\n    stopPolling: () => void;\r\n    subscribeToMore: (options: SubscribeToMoreOptions) => () => void;\r\n    updateQuery: (mapFn: (previousQueryResult: any, options: UpdateQueryOptions<any>) => any) => void;\r\n}\r\nexport declare type DataValue<TData, TGraphQLVariables = OperationVariables> = QueryControls<TData, TGraphQLVariables> & Partial<TData>;\r\nexport interface DataProps<TData, TGraphQLVariables = OperationVariables> {\r\n    data: DataValue<TData, TGraphQLVariables>;\r\n}\r\nexport interface MutateProps<TData = any, TGraphQLVariables = OperationVariables> {\r\n    mutate: MutationFunction<TData, TGraphQLVariables>;\r\n    result: MutationResult<TData>;\r\n}\r\nexport declare type ChildProps<TProps = {}, TData = {}, TGraphQLVariables = OperationVariables> = TProps & Partial<DataProps<TData, TGraphQLVariables>> & Partial<MutateProps<TData, TGraphQLVariables>>;\r\nexport declare type ChildDataProps<TProps = {}, TData = {}, TGraphQLVariables = OperationVariables> = TProps & DataProps<TData, TGraphQLVariables>;\r\nexport declare type ChildMutateProps<TProps = {}, TData = {}, TGraphQLVariables = OperationVariables> = TProps & MutateProps<TData, TGraphQLVariables>;\r\nexport interface OptionProps<TProps = any, TData = any, TGraphQLVariables = OperationVariables> extends Partial<DataProps<TData, TGraphQLVariables>>, Partial<MutateProps<TData, TGraphQLVariables>> {\r\n    ownProps: TProps;\r\n}\r\nexport interface OperationOption<TProps, TData, TGraphQLVariables = OperationVariables, TChildProps = ChildProps<TProps, TData, TGraphQLVariables>> {\r\n    options?: BaseQueryOptions<TGraphQLVariables> | BaseMutationOptions<TData, TGraphQLVariables> | ((props: TProps) => BaseQueryOptions<TGraphQLVariables> | BaseMutationOptions<TData, TGraphQLVariables>);\r\n    props?: (props: OptionProps<TProps, TData, TGraphQLVariables>, lastProps?: TChildProps | void) => TChildProps;\r\n    skip?: boolean | ((props: TProps) => boolean);\r\n    name?: string;\r\n    withRef?: boolean;\r\n    shouldResubscribe?: (props: TProps, nextProps: TProps) => boolean;\r\n    alias?: string;\r\n}\r\nexport declare type WithApolloClient<P> = P & {\r\n    client?: ApolloClient<any>;\r\n};\r\n",
      "@apollo/client/react/hoc/withApollo.d.ts": "import React from 'react';\r\nimport { OperationOption, WithApolloClient } from './types';\r\nexport declare function withApollo<TProps, TResult = any>(WrappedComponent: React.ComponentType<WithApolloClient<Omit<TProps, 'client'>>>, operationOptions?: OperationOption<TProps, TResult>): React.ComponentClass<Omit<TProps, 'client'>>;\r\n",
      "@apollo/client/react/hooks/index.d.ts": "export * from './useApolloClient';\r\nexport * from './useLazyQuery';\r\nexport * from './useMutation';\r\nexport * from './useQuery';\r\nexport * from './useSubscription';\r\nexport * from './useReactiveVar';\r\n",
      "@apollo/client/react/hooks/useApolloClient.d.ts": "import { ApolloClient } from '../../core';\r\nexport declare function useApolloClient(): ApolloClient<object>;\r\n",
      "@apollo/client/react/hooks/useLazyQuery.d.ts": "import { DocumentNode } from 'graphql';\r\nimport { TypedDocumentNode } from '@graphql-typed-document-node/core';\r\nimport { LazyQueryHookOptions, QueryTuple } from '../types/types';\r\nimport { OperationVariables } from '../../core';\r\nexport declare function useLazyQuery<TData = any, TVariables = OperationVariables>(query: DocumentNode | TypedDocumentNode<TData, TVariables>, options?: LazyQueryHookOptions<TData, TVariables>): QueryTuple<TData, TVariables>;\r\n",
      "@apollo/client/react/hooks/useMutation.d.ts": "import { DocumentNode } from 'graphql';\r\nimport { TypedDocumentNode } from '@graphql-typed-document-node/core';\r\nimport { MutationHookOptions, MutationTuple } from '../types/types';\r\nimport { OperationVariables } from '../../core';\r\nexport declare function useMutation<TData = any, TVariables = OperationVariables>(mutation: DocumentNode | TypedDocumentNode<TData, TVariables>, options?: MutationHookOptions<TData, TVariables>): MutationTuple<TData, TVariables>;\r\n",
      "@apollo/client/react/hooks/useQuery.d.ts": "import { DocumentNode } from 'graphql';\r\nimport { TypedDocumentNode } from '@graphql-typed-document-node/core';\r\nimport { QueryHookOptions, QueryResult } from '../types/types';\r\nimport { OperationVariables } from '../../core';\r\nexport declare function useQuery<TData = any, TVariables = OperationVariables>(query: DocumentNode | TypedDocumentNode<TData, TVariables>, options?: QueryHookOptions<TData, TVariables>): QueryResult<TData, TVariables>;\r\n",
      "@apollo/client/react/hooks/useReactiveVar.d.ts": "import { ReactiveVar } from '../../core';\r\nexport declare function useReactiveVar<T>(rv: ReactiveVar<T>): T;\r\n",
      "@apollo/client/react/hooks/useSubscription.d.ts": "import { DocumentNode } from 'graphql';\r\nimport { TypedDocumentNode } from '@graphql-typed-document-node/core';\r\nimport { SubscriptionHookOptions } from '../types/types';\r\nimport { OperationVariables } from '../../core';\r\nexport declare function useSubscription<TData = any, TVariables = OperationVariables>(subscription: DocumentNode | TypedDocumentNode<TData, TVariables>, options?: SubscriptionHookOptions<TData, TVariables>): {\r\n    variables: TVariables | undefined;\r\n    loading: boolean;\r\n    data?: TData | undefined;\r\n    error?: import(\"../../errors\").ApolloError | undefined;\r\n};\r\n",
      "@apollo/client/react/hooks/utils/useBaseQuery.d.ts": "import { DocumentNode } from 'graphql';\r\nimport { TypedDocumentNode } from '@graphql-typed-document-node/core';\r\nimport { QueryHookOptions, QueryTuple, QueryResult } from '../../types/types';\r\nimport { OperationVariables } from '../../../core';\r\nexport declare function useBaseQuery<TData = any, TVariables = OperationVariables>(query: DocumentNode | TypedDocumentNode<TData, TVariables>, options?: QueryHookOptions<TData, TVariables>, lazy?: boolean): QueryTuple<TData, TVariables> | QueryResult<TData, TVariables>;\r\n",
      "@apollo/client/react/hooks/utils/useDeepMemo.d.ts": "export declare function useDeepMemo<TKey, TValue>(memoFn: () => TValue, key: TKey): TValue;\r\n",
      "@apollo/client/react/index.d.ts": "export { ApolloProvider, ApolloConsumer, getApolloContext, resetApolloContext, ApolloContextValue } from './context';\r\nexport * from './hooks';\r\nexport { DocumentType, IDocumentDefinition, operationName, parser } from './parser';\r\nexport * from './types/types';\r\n",
      "@apollo/client/react/parser/index.d.ts": "import { DocumentNode, VariableDefinitionNode } from 'graphql';\r\nexport declare enum DocumentType {\r\n    Query = 0,\r\n    Mutation = 1,\r\n    Subscription = 2\r\n}\r\nexport interface IDocumentDefinition {\r\n    type: DocumentType;\r\n    name: string;\r\n    variables: ReadonlyArray<VariableDefinitionNode>;\r\n}\r\nexport declare function operationName(type: DocumentType): string;\r\nexport declare function parser(document: DocumentNode): IDocumentDefinition;\r\n",
      "@apollo/client/react/ssr/getDataFromTree.d.ts": "import React from 'react';\r\nexport declare function getDataFromTree(tree: React.ReactNode, context?: {\r\n    [key: string]: any;\r\n}): Promise<string>;\r\nexport declare type GetMarkupFromTreeOptions = {\r\n    tree: React.ReactNode;\r\n    context?: {\r\n        [key: string]: any;\r\n    };\r\n    renderFunction?: (tree: React.ReactElement<any>) => string | PromiseLike<string>;\r\n};\r\nexport declare function getMarkupFromTree({ tree, context, renderFunction }: GetMarkupFromTreeOptions): Promise<string>;\r\n",
      "@apollo/client/react/ssr/index.d.ts": "export { getMarkupFromTree, getDataFromTree } from './getDataFromTree';\r\nexport { renderToStringWithData } from './renderToStringWithData';\r\nexport { RenderPromises } from './RenderPromises';\r\n",
      "@apollo/client/react/ssr/RenderPromises.d.ts": "/// <reference types=\"react\" />\r\nimport { ObservableQuery } from '../../core';\r\nimport { QueryDataOptions } from '../types/types';\r\nimport { QueryData } from '../data/QueryData';\r\nexport declare class RenderPromises {\r\n    private queryPromises;\r\n    private queryInfoTrie;\r\n    registerSSRObservable<TData, TVariables>(observable: ObservableQuery<any, TVariables>, props: QueryDataOptions<TData, TVariables>): void;\r\n    getSSRObservable<TData, TVariables>(props: QueryDataOptions<TData, TVariables>): ObservableQuery<any, any> | null;\r\n    addQueryPromise<TData, TVariables>(queryInstance: QueryData<TData, TVariables>, finish: () => React.ReactNode): React.ReactNode;\r\n    hasPromises(): boolean;\r\n    consumeAndAwaitPromises(): Promise<any[]>;\r\n    private lookupQueryInfo;\r\n}\r\n",
      "@apollo/client/react/ssr/renderToStringWithData.d.ts": "import { ReactElement } from 'react';\r\nexport declare function renderToStringWithData(component: ReactElement<any>): Promise<string>;\r\n",
      "@apollo/client/react/types/types.d.ts": "/// <reference types=\"zen-observable\" />\r\nimport { ReactNode } from 'react';\r\nimport { DocumentNode } from 'graphql';\r\nimport { TypedDocumentNode } from '@graphql-typed-document-node/core';\r\nimport { Observable } from '../../utilities';\r\nimport { FetchResult } from '../../link/core';\r\nimport { ApolloClient } from '../../core';\r\nimport { ApolloError } from '../../errors';\r\nimport { ApolloQueryResult, ErrorPolicy, FetchMoreOptions, FetchMoreQueryOptions, FetchPolicy, MutationUpdaterFn, NetworkStatus, ObservableQuery, OperationVariables, PureQueryOptions, WatchQueryFetchPolicy } from '../../core';\r\nexport declare type Context = Record<string, any>;\r\nexport declare type CommonOptions<TOptions> = TOptions & {\r\n    client?: ApolloClient<object>;\r\n};\r\nexport interface BaseQueryOptions<TVariables = OperationVariables> {\r\n    ssr?: boolean;\r\n    variables?: TVariables;\r\n    fetchPolicy?: WatchQueryFetchPolicy;\r\n    nextFetchPolicy?: WatchQueryFetchPolicy;\r\n    errorPolicy?: ErrorPolicy;\r\n    pollInterval?: number;\r\n    client?: ApolloClient<any>;\r\n    notifyOnNetworkStatusChange?: boolean;\r\n    context?: Context;\r\n    partialRefetch?: boolean;\r\n    returnPartialData?: boolean;\r\n}\r\nexport interface QueryFunctionOptions<TData = any, TVariables = OperationVariables> extends BaseQueryOptions<TVariables> {\r\n    displayName?: string;\r\n    skip?: boolean;\r\n    onCompleted?: (data: TData) => void;\r\n    onError?: (error: ApolloError) => void;\r\n}\r\nexport declare type ObservableQueryFields<TData, TVariables> = Pick<ObservableQuery<TData, TVariables>, 'startPolling' | 'stopPolling' | 'subscribeToMore' | 'updateQuery' | 'refetch' | 'variables'> & {\r\n    fetchMore: (<K extends keyof TVariables>(fetchMoreOptions: FetchMoreQueryOptions<TVariables, K, TData> & FetchMoreOptions<TData, TVariables>) => Promise<ApolloQueryResult<TData>>) & (<TData2, TVariables2, K extends keyof TVariables2>(fetchMoreOptions: {\r\n        query?: DocumentNode | TypedDocumentNode<TData, TVariables>;\r\n    } & FetchMoreQueryOptions<TVariables2, K, TData> & FetchMoreOptions<TData2, TVariables2>) => Promise<ApolloQueryResult<TData2>>);\r\n};\r\nexport interface QueryResult<TData = any, TVariables = OperationVariables> extends ObservableQueryFields<TData, TVariables> {\r\n    client: ApolloClient<any>;\r\n    data: TData | undefined;\r\n    error?: ApolloError;\r\n    loading: boolean;\r\n    networkStatus: NetworkStatus;\r\n    called: true;\r\n}\r\nexport interface QueryDataOptions<TData = any, TVariables = OperationVariables> extends QueryFunctionOptions<TData, TVariables> {\r\n    children?: (result: QueryResult<TData, TVariables>) => ReactNode;\r\n    query: DocumentNode | TypedDocumentNode<TData, TVariables>;\r\n}\r\nexport interface QueryHookOptions<TData = any, TVariables = OperationVariables> extends QueryFunctionOptions<TData, TVariables> {\r\n    query?: DocumentNode | TypedDocumentNode<TData, TVariables>;\r\n}\r\nexport interface LazyQueryHookOptions<TData = any, TVariables = OperationVariables> extends Omit<QueryFunctionOptions<TData, TVariables>, 'skip'> {\r\n    query?: DocumentNode | TypedDocumentNode<TData, TVariables>;\r\n}\r\nexport interface QueryPreviousData<TData, TVariables> {\r\n    client?: ApolloClient<object>;\r\n    query?: DocumentNode | TypedDocumentNode<TData, TVariables>;\r\n    observableQueryOptions?: {};\r\n    result?: QueryResult<TData, TVariables> | null;\r\n    loading?: boolean;\r\n    options?: QueryDataOptions<TData, TVariables>;\r\n    error?: ApolloError;\r\n}\r\nexport interface QueryLazyOptions<TVariables> {\r\n    variables?: TVariables;\r\n    context?: Context;\r\n}\r\ndeclare type UnexecutedLazyFields = {\r\n    loading: false;\r\n    networkStatus: NetworkStatus.ready;\r\n    called: false;\r\n    data: undefined;\r\n};\r\ndeclare type Impartial<T> = {\r\n    [P in keyof T]?: never;\r\n};\r\ndeclare type AbsentLazyResultFields = Omit<Impartial<QueryResult<unknown, unknown>>, keyof UnexecutedLazyFields>;\r\ndeclare type UnexecutedLazyResult = UnexecutedLazyFields & AbsentLazyResultFields;\r\nexport declare type LazyQueryResult<TData, TVariables> = UnexecutedLazyResult | QueryResult<TData, TVariables>;\r\nexport declare type QueryTuple<TData, TVariables> = [(options?: QueryLazyOptions<TVariables>) => void, LazyQueryResult<TData, TVariables>];\r\nexport declare type RefetchQueriesFunction = (...args: any[]) => Array<string | PureQueryOptions>;\r\nexport interface BaseMutationOptions<TData = any, TVariables = OperationVariables> {\r\n    variables?: TVariables;\r\n    optimisticResponse?: TData | ((vars: TVariables) => TData);\r\n    refetchQueries?: Array<string | PureQueryOptions> | RefetchQueriesFunction;\r\n    awaitRefetchQueries?: boolean;\r\n    errorPolicy?: ErrorPolicy;\r\n    update?: MutationUpdaterFn<TData>;\r\n    client?: ApolloClient<object>;\r\n    notifyOnNetworkStatusChange?: boolean;\r\n    context?: Context;\r\n    onCompleted?: (data: TData) => void;\r\n    onError?: (error: ApolloError) => void;\r\n    fetchPolicy?: Extract<WatchQueryFetchPolicy, 'no-cache'>;\r\n    ignoreResults?: boolean;\r\n}\r\nexport interface MutationFunctionOptions<TData = any, TVariables = OperationVariables> {\r\n    variables?: TVariables;\r\n    optimisticResponse?: TData | ((vars: TVariables) => TData);\r\n    refetchQueries?: Array<string | PureQueryOptions> | RefetchQueriesFunction;\r\n    awaitRefetchQueries?: boolean;\r\n    update?: MutationUpdaterFn<TData>;\r\n    context?: Context;\r\n    fetchPolicy?: WatchQueryFetchPolicy;\r\n}\r\nexport interface MutationResult<TData = any> {\r\n    data?: TData | null;\r\n    error?: ApolloError;\r\n    loading: boolean;\r\n    called: boolean;\r\n    client: ApolloClient<object>;\r\n}\r\nexport declare type MutationFunction<TData = any, TVariables = OperationVariables> = (options?: MutationFunctionOptions<TData, TVariables>) => Promise<FetchResult<TData>>;\r\nexport interface MutationHookOptions<TData = any, TVariables = OperationVariables> extends BaseMutationOptions<TData, TVariables> {\r\n    mutation?: DocumentNode | TypedDocumentNode<TData, TVariables>;\r\n}\r\nexport interface MutationDataOptions<TData = any, TVariables = OperationVariables> extends BaseMutationOptions<TData, TVariables> {\r\n    mutation: DocumentNode | TypedDocumentNode<TData, TVariables>;\r\n}\r\nexport declare type MutationTuple<TData, TVariables> = [(options?: MutationFunctionOptions<TData, TVariables>) => Promise<FetchResult<TData>>, MutationResult<TData>];\r\nexport interface OnSubscriptionDataOptions<TData = any> {\r\n    client: ApolloClient<object>;\r\n    subscriptionData: SubscriptionResult<TData>;\r\n}\r\nexport interface BaseSubscriptionOptions<TData = any, TVariables = OperationVariables> {\r\n    variables?: TVariables;\r\n    fetchPolicy?: FetchPolicy;\r\n    shouldResubscribe?: boolean | ((options: BaseSubscriptionOptions<TData, TVariables>) => boolean);\r\n    client?: ApolloClient<object>;\r\n    skip?: boolean;\r\n    onSubscriptionData?: (options: OnSubscriptionDataOptions<TData>) => any;\r\n    onSubscriptionComplete?: () => void;\r\n}\r\nexport interface SubscriptionResult<TData = any> {\r\n    loading: boolean;\r\n    data?: TData;\r\n    error?: ApolloError;\r\n}\r\nexport interface SubscriptionHookOptions<TData = any, TVariables = OperationVariables> extends BaseSubscriptionOptions<TData, TVariables> {\r\n    subscription?: DocumentNode | TypedDocumentNode<TData, TVariables>;\r\n}\r\nexport interface SubscriptionDataOptions<TData = any, TVariables = OperationVariables> extends BaseSubscriptionOptions<TData, TVariables> {\r\n    subscription: DocumentNode | TypedDocumentNode<TData, TVariables>;\r\n    children?: null | ((result: SubscriptionResult<TData>) => JSX.Element | null);\r\n}\r\nexport interface SubscriptionCurrentObservable {\r\n    query?: Observable<any>;\r\n    subscription?: ZenObservable.Subscription;\r\n}\r\nexport {};\r\n",
      "@apollo/client/testing/index.d.ts": "export * from '../utilities/testing';\r\n",
      "@apollo/client/utilities/common/arrays.d.ts": "export declare function isNonEmptyArray<T>(value?: ArrayLike<T>): value is Array<T>;\r\n",
      "@apollo/client/utilities/common/canUse.d.ts": "export declare const canUseWeakMap: boolean;\r\n",
      "@apollo/client/utilities/common/cloneDeep.d.ts": "export declare function cloneDeep<T>(value: T): T;\r\n",
      "@apollo/client/utilities/common/compact.d.ts": "import { TupleToIntersection } from './mergeDeep';\r\nexport declare function compact<TArgs extends object[]>(...objects: TArgs): TupleToIntersection<TArgs>;\r\n",
      "@apollo/client/utilities/common/environment.d.ts": "export declare function getEnv(): string | undefined;\r\nexport declare function isEnv(env: string): boolean;\r\nexport declare function isDevelopment(): boolean;\r\nexport declare function isTest(): boolean;\r\n",
      "@apollo/client/utilities/common/errorHandling.d.ts": "import { ExecutionResult } from 'graphql';\r\nexport declare function graphQLResultHasError(result: ExecutionResult): boolean;\r\n",
      "@apollo/client/utilities/common/filterInPlace.d.ts": "export declare function filterInPlace<T>(array: T[], test: (elem: T) => boolean, context?: any): T[];\r\n",
      "@apollo/client/utilities/common/maybeDeepFreeze.d.ts": "export declare function maybeDeepFreeze<T>(obj: T): T;\r\n",
      "@apollo/client/utilities/common/mergeDeep.d.ts": "export declare type TupleToIntersection<T extends any[]> = T extends [infer A] ? A : T extends [infer A, infer B] ? A & B : T extends [infer A, infer B, infer C] ? A & B & C : T extends [infer A, infer B, infer C, infer D] ? A & B & C & D : T extends [infer A, infer B, infer C, infer D, infer E] ? A & B & C & D & E : T extends (infer U)[] ? U : any;\r\nexport declare function mergeDeep<T extends any[]>(...sources: T): TupleToIntersection<T>;\r\nexport declare function mergeDeepArray<T>(sources: T[]): T;\r\ndeclare function isObject(obj: any): obj is Record<string | number, any>;\r\nexport declare type ReconcilerFunction<TContextArgs extends any[]> = (this: DeepMerger<TContextArgs>, target: Record<string | number, any>, source: Record<string | number, any>, property: string | number, ...context: TContextArgs) => any;\r\nexport declare class DeepMerger<TContextArgs extends any[]> {\r\n    private reconciler;\r\n    constructor(reconciler?: ReconcilerFunction<TContextArgs>);\r\n    merge(target: any, source: any, ...context: TContextArgs): any;\r\n    isObject: typeof isObject;\r\n    private pastCopies;\r\n    shallowCopyForMerge<T>(value: T): T;\r\n}\r\nexport {};\r\n",
      "@apollo/client/utilities/graphql/directives.d.ts": "import { SelectionNode, DirectiveNode, DocumentNode, ArgumentNode, ASTNode } from 'graphql';\r\nexport declare type DirectiveInfo = {\r\n    [fieldName: string]: {\r\n        [argName: string]: any;\r\n    };\r\n};\r\nexport declare function shouldInclude({ directives }: SelectionNode, variables?: Record<string, any>): boolean;\r\nexport declare function getDirectiveNames(root: ASTNode): string[];\r\nexport declare function hasDirectives(names: string[], root: ASTNode): boolean;\r\nexport declare function hasClientExports(document: DocumentNode): boolean;\r\nexport declare type InclusionDirectives = Array<{\r\n    directive: DirectiveNode;\r\n    ifArgument: ArgumentNode;\r\n}>;\r\nexport declare function getInclusionDirectives(directives: ReadonlyArray<DirectiveNode>): InclusionDirectives;\r\n",
      "@apollo/client/utilities/graphql/fragments.d.ts": "import { DocumentNode, FragmentDefinitionNode, InlineFragmentNode, SelectionNode } from 'graphql';\r\nexport declare function getFragmentQueryDocument(document: DocumentNode, fragmentName?: string): DocumentNode;\r\nexport interface FragmentMap {\r\n    [fragmentName: string]: FragmentDefinitionNode;\r\n}\r\nexport declare function createFragmentMap(fragments?: FragmentDefinitionNode[]): FragmentMap;\r\nexport declare function getFragmentFromSelection(selection: SelectionNode, fragmentMap?: FragmentMap): InlineFragmentNode | FragmentDefinitionNode | null;\r\n",
      "@apollo/client/utilities/graphql/getFromAST.d.ts": "import { DocumentNode, OperationDefinitionNode, FragmentDefinitionNode } from 'graphql';\r\nexport declare function checkDocument(doc: DocumentNode): DocumentNode;\r\nexport declare function getOperationDefinition(doc: DocumentNode): OperationDefinitionNode | undefined;\r\nexport declare function getOperationName(doc: DocumentNode): string | null;\r\nexport declare function getFragmentDefinitions(doc: DocumentNode): FragmentDefinitionNode[];\r\nexport declare function getQueryDefinition(doc: DocumentNode): OperationDefinitionNode;\r\nexport declare function getFragmentDefinition(doc: DocumentNode): FragmentDefinitionNode;\r\nexport declare function getMainDefinition(queryDoc: DocumentNode): OperationDefinitionNode | FragmentDefinitionNode;\r\nexport declare function getDefaultValues(definition: OperationDefinitionNode | undefined): Record<string, any>;\r\n",
      "@apollo/client/utilities/graphql/storeUtils.d.ts": "import { DirectiveNode, FieldNode, VariableNode, InlineFragmentNode, ValueNode, SelectionNode, NameNode, SelectionSetNode } from 'graphql';\r\nimport { FragmentMap } from './fragments';\r\nexport interface Reference {\r\n    readonly __ref: string;\r\n}\r\nexport declare function makeReference(id: string): Reference;\r\nexport declare function isReference(obj: any): obj is Reference;\r\nexport declare type StoreValue = number | string | string[] | Reference | Reference[] | null | undefined | void | Object;\r\nexport interface StoreObject {\r\n    __typename?: string;\r\n    [storeFieldName: string]: StoreValue;\r\n}\r\nexport declare function valueToObjectRepresentation(argObj: any, name: NameNode, value: ValueNode, variables?: Object): void;\r\nexport declare function storeKeyNameFromField(field: FieldNode, variables?: Object): string;\r\nexport declare type Directives = {\r\n    [directiveName: string]: {\r\n        [argName: string]: any;\r\n    };\r\n};\r\nexport declare function getStoreKeyName(fieldName: string, args?: Record<string, any> | null, directives?: Directives): string;\r\nexport declare function argumentsObjectFromField(field: FieldNode | DirectiveNode, variables?: Record<string, any>): Object | null;\r\nexport declare function resultKeyNameFromField(field: FieldNode): string;\r\nexport declare function getTypenameFromResult(result: Record<string, any>, selectionSet: SelectionSetNode, fragmentMap?: FragmentMap): string | undefined;\r\nexport declare function isField(selection: SelectionNode): selection is FieldNode;\r\nexport declare function isInlineFragment(selection: SelectionNode): selection is InlineFragmentNode;\r\nexport declare type VariableValue = (node: VariableNode) => any;\r\n",
      "@apollo/client/utilities/graphql/transform.d.ts": "import { DocumentNode, FieldNode, DirectiveNode, FragmentDefinitionNode, ArgumentNode, FragmentSpreadNode, VariableDefinitionNode } from 'graphql';\r\nexport declare type RemoveNodeConfig<N> = {\r\n    name?: string;\r\n    test?: (node: N) => boolean;\r\n    remove?: boolean;\r\n};\r\nexport declare type GetNodeConfig<N> = {\r\n    name?: string;\r\n    test?: (node: N) => boolean;\r\n};\r\nexport declare type RemoveDirectiveConfig = RemoveNodeConfig<DirectiveNode>;\r\nexport declare type GetDirectiveConfig = GetNodeConfig<DirectiveNode>;\r\nexport declare type RemoveArgumentsConfig = RemoveNodeConfig<ArgumentNode>;\r\nexport declare type GetFragmentSpreadConfig = GetNodeConfig<FragmentSpreadNode>;\r\nexport declare type RemoveFragmentSpreadConfig = RemoveNodeConfig<FragmentSpreadNode>;\r\nexport declare type RemoveFragmentDefinitionConfig = RemoveNodeConfig<FragmentDefinitionNode>;\r\nexport declare type RemoveVariableDefinitionConfig = RemoveNodeConfig<VariableDefinitionNode>;\r\nexport declare function removeDirectivesFromDocument(directives: RemoveDirectiveConfig[], doc: DocumentNode): DocumentNode | null;\r\nexport declare function addTypenameToDocument(doc: DocumentNode): DocumentNode;\r\nexport declare namespace addTypenameToDocument {\r\n    var added: (field: FieldNode) => boolean;\r\n}\r\nexport interface addTypenameToDocument {\r\n    added(field: FieldNode): boolean;\r\n}\r\nexport declare function removeConnectionDirectiveFromDocument(doc: DocumentNode): DocumentNode | null;\r\nexport declare function removeArgumentsFromDocument(config: RemoveArgumentsConfig[], doc: DocumentNode): DocumentNode | null;\r\nexport declare function removeFragmentSpreadFromDocument(config: RemoveFragmentSpreadConfig[], doc: DocumentNode): DocumentNode | null;\r\nexport declare function buildQueryFromSelectionSet(document: DocumentNode): DocumentNode;\r\nexport declare function removeClientSetsFromDocument(document: DocumentNode): DocumentNode | null;\r\n",
      "@apollo/client/utilities/index.d.ts": "export { DirectiveInfo, InclusionDirectives, shouldInclude, hasDirectives, hasClientExports, getDirectiveNames, getInclusionDirectives, } from './graphql/directives';\r\nexport { FragmentMap, createFragmentMap, getFragmentQueryDocument, getFragmentFromSelection, } from './graphql/fragments';\r\nexport { checkDocument, getOperationDefinition, getOperationName, getFragmentDefinitions, getQueryDefinition, getFragmentDefinition, getMainDefinition, getDefaultValues, } from './graphql/getFromAST';\r\nexport { StoreObject, Reference, StoreValue, Directives, VariableValue, makeReference, isReference, isField, isInlineFragment, valueToObjectRepresentation, storeKeyNameFromField, argumentsObjectFromField, resultKeyNameFromField, getStoreKeyName, getTypenameFromResult, } from './graphql/storeUtils';\r\nexport { RemoveNodeConfig, GetNodeConfig, RemoveDirectiveConfig, GetDirectiveConfig, RemoveArgumentsConfig, GetFragmentSpreadConfig, RemoveFragmentSpreadConfig, RemoveFragmentDefinitionConfig, RemoveVariableDefinitionConfig, addTypenameToDocument, buildQueryFromSelectionSet, removeDirectivesFromDocument, removeConnectionDirectiveFromDocument, removeArgumentsFromDocument, removeFragmentSpreadFromDocument, removeClientSetsFromDocument, } from './graphql/transform';\r\nexport { concatPagination, offsetLimitPagination, relayStylePagination, } from './policies/pagination';\r\nexport { Observable, Observer, ObservableSubscription } from './observables/Observable';\r\nexport * from './common/mergeDeep';\r\nexport * from './common/cloneDeep';\r\nexport * from './common/maybeDeepFreeze';\r\nexport * from './observables/iteration';\r\nexport * from './observables/asyncMap';\r\nexport * from './observables/Concast';\r\nexport * from './common/arrays';\r\nexport * from './common/errorHandling';\r\nexport * from './common/canUse';\r\nexport * from './common/compact';\r\n",
      "@apollo/client/utilities/observables/asyncMap.d.ts": "/// <reference types=\"zen-observable\" />\r\nimport { Observable } from \"./Observable\";\r\nexport declare function asyncMap<V, R>(observable: Observable<V>, mapFn: (value: V) => R | PromiseLike<R>, catchFn?: (error: any) => R | PromiseLike<R>): Observable<R>;\r\n",
      "@apollo/client/utilities/observables/Concast.d.ts": "/// <reference types=\"zen-observable\" />\r\nimport { Observable, Observer } from \"./Observable\";\r\ndeclare type MaybeAsync<T> = T | PromiseLike<T>;\r\ndeclare type Source<T> = MaybeAsync<Observable<T>>;\r\nexport declare type ConcastSourcesIterable<T> = Iterable<Source<T>>;\r\nexport declare class Concast<T> extends Observable<T> {\r\n    private observers;\r\n    private sub?;\r\n    constructor(sources: MaybeAsync<ConcastSourcesIterable<T>>);\r\n    private sources;\r\n    private start;\r\n    addObserver(observer: Observer<T>): void;\r\n    removeObserver(observer: Observer<T>, quietly?: boolean): void;\r\n    private resolve;\r\n    private reject;\r\n    readonly promise: Promise<T>;\r\n    private latest?;\r\n    private handlers;\r\n    cleanup(callback: () => any): void;\r\n    cancel: (reason: any) => void;\r\n}\r\nexport {};\r\n",
      "@apollo/client/utilities/observables/iteration.d.ts": "import { Observer } from \"./Observable\";\r\nexport declare function iterateObserversSafely<E, A>(observers: Set<Observer<E>>, method: keyof Observer<E>, argument?: A): void;\r\n",
      "@apollo/client/utilities/observables/Observable.d.ts": "import Observable from 'zen-observable';\r\nimport 'symbol-observable';\r\nexport declare type ObservableSubscription = ZenObservable.Subscription;\r\nexport declare type Observer<T> = ZenObservable.Observer<T>;\r\ndeclare global {\r\n    interface Observable<T> {\r\n        ['@@observable'](): Observable<T>;\r\n    }\r\n}\r\nexport { Observable };\r\n",
      "@apollo/client/utilities/policies/pagination.d.ts": "import { FieldPolicy, Reference } from '../../cache';\r\ndeclare type KeyArgs = FieldPolicy<any>[\"keyArgs\"];\r\nexport declare function concatPagination<T = Reference>(keyArgs?: KeyArgs): FieldPolicy<T[]>;\r\nexport declare function offsetLimitPagination<T = Reference>(keyArgs?: KeyArgs): FieldPolicy<T[]>;\r\ndeclare type TEdge<TNode> = {\r\n    cursor?: string;\r\n    node: TNode;\r\n} | (Reference & {\r\n    cursor?: string;\r\n});\r\ndeclare type TPageInfo = {\r\n    hasPreviousPage: boolean;\r\n    hasNextPage: boolean;\r\n    startCursor: string;\r\n    endCursor: string;\r\n};\r\ndeclare type TExistingRelay<TNode> = Readonly<{\r\n    edges: TEdge<TNode>[];\r\n    pageInfo: TPageInfo;\r\n}>;\r\ndeclare type TIncomingRelay<TNode> = {\r\n    edges?: TEdge<TNode>[];\r\n    pageInfo?: TPageInfo;\r\n};\r\ndeclare type RelayFieldPolicy<TNode> = FieldPolicy<TExistingRelay<TNode>, TIncomingRelay<TNode>, TIncomingRelay<TNode>>;\r\nexport declare function relayStylePagination<TNode = Reference>(keyArgs?: KeyArgs): RelayFieldPolicy<TNode>;\r\nexport {};\r\n",
      "@apollo/client/utilities/testing/index.d.ts": "export { MockedProvider, MockedProviderProps } from './mocking/MockedProvider';\r\nexport { MockLink, mockSingleLink, MockedResponse } from './mocking/mockLink';\r\nexport { MockSubscriptionLink, mockObservableLink } from './mocking/mockSubscriptionLink';\r\nexport { createMockClient } from './mocking/mockClient';\r\nexport { stripSymbols } from './stripSymbols';\r\nexport { default as subscribeAndCount } from './subscribeAndCount';\r\nexport { itAsync } from './itAsync';\r\n",
      "@apollo/client/utilities/testing/itAsync.d.ts": "declare const wrappedIt: (message: string, callback: (resolve: (result?: any) => void, reject: (reason?: any) => void) => any, timeout?: number | undefined) => void;\r\nexport declare function itAsync(...args: Parameters<typeof wrappedIt>): any;\r\nexport declare namespace itAsync {\r\n    const only: (message: string, callback: (resolve: (result?: any) => void, reject: (reason?: any) => void) => any, timeout?: number | undefined) => void;\r\n    const skip: (message: string, callback: (resolve: (result?: any) => void, reject: (reason?: any) => void) => any, timeout?: number | undefined) => void;\r\n    const todo: (message: string, callback: (resolve: (result?: any) => void, reject: (reason?: any) => void) => any, timeout?: number | undefined) => void;\r\n}\r\nexport {};\r\n",
      "@apollo/client/utilities/testing/mocking/mockClient.d.ts": "import { DocumentNode } from 'graphql';\r\nimport { ApolloClient } from '../../../core';\r\nimport { NormalizedCacheObject } from '../../../cache';\r\nexport declare function createMockClient<TData>(data: TData, query: DocumentNode, variables?: {}): ApolloClient<NormalizedCacheObject>;\r\n",
      "@apollo/client/utilities/testing/mocking/MockedProvider.d.ts": "import React from 'react';\r\nimport { ApolloClient, DefaultOptions } from '../../../core';\r\nimport { MockedResponse } from './mockLink';\r\nimport { ApolloLink } from '../../../link/core';\r\nimport { Resolvers } from '../../../core';\r\nimport { ApolloCache } from '../../../cache';\r\nexport interface MockedProviderProps<TSerializedCache = {}> {\r\n    mocks?: ReadonlyArray<MockedResponse>;\r\n    addTypename?: boolean;\r\n    defaultOptions?: DefaultOptions;\r\n    cache?: ApolloCache<TSerializedCache>;\r\n    resolvers?: Resolvers;\r\n    childProps?: object;\r\n    children?: React.ReactElement;\r\n    link?: ApolloLink;\r\n}\r\nexport interface MockedProviderState {\r\n    client: ApolloClient<any>;\r\n}\r\nexport declare class MockedProvider extends React.Component<MockedProviderProps, MockedProviderState> {\r\n    static defaultProps: MockedProviderProps;\r\n    constructor(props: MockedProviderProps);\r\n    render(): JSX.Element | null;\r\n    componentWillUnmount(): void;\r\n}\r\n",
      "@apollo/client/utilities/testing/mocking/mockFetch.d.ts": "import 'whatwg-fetch';\r\nexport interface MockedIResponse {\r\n    ok: boolean;\r\n    status: number;\r\n    statusText?: string;\r\n    json(): Promise<Object>;\r\n}\r\nexport interface MockedFetchResponse {\r\n    url: string;\r\n    opts: RequestInit;\r\n    result: MockedIResponse;\r\n    delay?: number;\r\n}\r\nexport declare function createMockedIResponse(result: Object, options?: any): MockedIResponse;\r\nexport declare class MockFetch {\r\n    private mockedResponsesByKey;\r\n    constructor(...mockedResponses: MockedFetchResponse[]);\r\n    addMockedResponse(mockedResponse: MockedFetchResponse): void;\r\n    fetch(url: string, opts: RequestInit): Promise<unknown>;\r\n    fetchParamsToKey(url: string, opts: RequestInit): string;\r\n    getFetch(): any;\r\n}\r\nexport declare function createMockFetch(...mockedResponses: MockedFetchResponse[]): any;\r\n",
      "@apollo/client/utilities/testing/mocking/mockLink.d.ts": "/// <reference types=\"zen-observable\" />\r\nimport { ApolloLink, Operation, GraphQLRequest, FetchResult } from '../../../link/core';\r\nimport { Observable } from '../../../utilities';\r\nexport declare type ResultFunction<T> = () => T;\r\nexport interface MockedResponse<TData = Record<string, any>> {\r\n    request: GraphQLRequest;\r\n    result?: FetchResult<TData> | ResultFunction<FetchResult<TData>>;\r\n    error?: Error;\r\n    delay?: number;\r\n    newData?: ResultFunction<FetchResult>;\r\n}\r\nexport declare class MockLink extends ApolloLink {\r\n    operation: Operation;\r\n    addTypename: Boolean;\r\n    private mockedResponsesByKey;\r\n    constructor(mockedResponses: ReadonlyArray<MockedResponse>, addTypename?: Boolean);\r\n    addMockedResponse(mockedResponse: MockedResponse): void;\r\n    request(operation: Operation): Observable<FetchResult> | null;\r\n    private normalizeMockedResponse;\r\n}\r\nexport interface MockApolloLink extends ApolloLink {\r\n    operation?: Operation;\r\n}\r\nexport declare function mockSingleLink(...mockedResponses: Array<any>): MockApolloLink;\r\n",
      "@apollo/client/utilities/testing/mocking/mockQueryManager.d.ts": "import { QueryManager } from '../../../core/QueryManager';\r\nimport { MockedResponse } from './mockLink';\r\ndeclare const _default: (reject: (reason: any) => any, ...mockedResponses: MockedResponse[]) => QueryManager<import(\"../../..\").NormalizedCacheObject>;\r\nexport default _default;\r\n",
      "@apollo/client/utilities/testing/mocking/mockSubscriptionLink.d.ts": "/// <reference types=\"zen-observable\" />\r\nimport { Observable } from '../../../utilities';\r\nimport { ApolloLink, FetchResult, Operation } from '../../../link/core';\r\nexport interface MockedSubscription {\r\n    request: Operation;\r\n}\r\nexport interface MockedSubscriptionResult {\r\n    result?: FetchResult;\r\n    error?: Error;\r\n    delay?: number;\r\n}\r\nexport declare class MockSubscriptionLink extends ApolloLink {\r\n    unsubscribers: any[];\r\n    setups: any[];\r\n    operation: Operation;\r\n    private observers;\r\n    constructor();\r\n    request(operation: Operation): Observable<FetchResult<{\r\n        [key: string]: any;\r\n    }, Record<string, any>, Record<string, any>>>;\r\n    simulateResult(result: MockedSubscriptionResult, complete?: boolean): void;\r\n    simulateComplete(): void;\r\n    onSetup(listener: any): void;\r\n    onUnsubscribe(listener: any): void;\r\n}\r\nexport declare function mockObservableLink(): MockSubscriptionLink;\r\n",
      "@apollo/client/utilities/testing/mocking/mockWatchQuery.d.ts": "import { MockedResponse } from './mockLink';\r\nimport { ObservableQuery } from '../../../core/ObservableQuery';\r\ndeclare const _default: (reject: (reason: any) => any, ...mockedResponses: MockedResponse[]) => ObservableQuery<any>;\r\nexport default _default;\r\n",
      "@apollo/client/utilities/testing/observableToPromise.d.ts": "import { ObservableQuery } from '../../core/ObservableQuery';\r\nimport { ApolloQueryResult } from '../../core/types';\r\nimport { ObservableSubscription } from '../../utilities/observables/Observable';\r\nexport declare type Options = {\r\n    observable: ObservableQuery<any>;\r\n    shouldResolve?: boolean;\r\n    wait?: number;\r\n    errorCallbacks?: ((error: Error) => any)[];\r\n};\r\nexport declare type ResultCallback = ((result: ApolloQueryResult<any>) => any);\r\nexport declare function observableToPromiseAndSubscription({ observable, shouldResolve, wait, errorCallbacks }: Options, ...cbs: ResultCallback[]): {\r\n    promise: Promise<any[]>;\r\n    subscription: ObservableSubscription;\r\n};\r\nexport default function (options: Options, ...cbs: ResultCallback[]): Promise<any[]>;\r\n",
      "@apollo/client/utilities/testing/stripSymbols.d.ts": "export declare function stripSymbols<T>(data: T): T;\r\n",
      "@apollo/client/utilities/testing/subscribeAndCount.d.ts": "import { ObservableQuery } from '../../core/ObservableQuery';\r\nimport { ApolloQueryResult } from '../../core/types';\r\nimport { ObservableSubscription } from '../../utilities/observables/Observable';\r\nexport default function subscribeAndCount(reject: (reason: any) => any, observable: ObservableQuery<any>, cb: (handleCount: number, result: ApolloQueryResult<any>) => any): ObservableSubscription;\r\n",
      "@apollo/client/utilities/testing/wrap.d.ts": "declare const _default: <TArgs extends any[], TResult>(reject: (reason: any) => any, cb: (...args: TArgs) => TResult) => (...args: TArgs) => TResult | undefined;\r\nexport default _default;\r\nexport declare function withError(func: Function, regex: RegExp): any;\r\n",
      "@apollo/client/version.d.ts": "export declare const version = \"local\";\r\n"
    }
  }
  